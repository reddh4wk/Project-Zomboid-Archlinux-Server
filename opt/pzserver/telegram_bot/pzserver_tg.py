#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    @@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  ,@@@@@@@@@@@@@@@@@@@@@  @@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@%        @@       @@      @@   /@@&     .@@@     #%    /@@@@  .      @@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@%  /@@  .@&  #@@@@  ,@@,  @&  /@@  .@@  /@.  @@@@@@  *@@@@@, @@      @@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  /@@  ,@@  #@@@%  *@@   @@  (@&  ,@@@@@@  .@@@@@@  *@@@@@  @.    ,&*@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  ,@@  #@@  #@@@@, .@@  #@@  (@@*  @@@(/@(  @@@ /@  *@@@@@@%   (. .@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@.  /@@@@@@@@@@@@@@@@@@@@@#@%  %@@@@@@@@@@@@@@@@@@@@@@@@@@@@,  .@@%  @@@@@@@@@@@@@@@@@@@@@@@@@
#@                 @@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@&&&@@@@@@@@@@@@@@@@@@   (@@@  (@@@@@@@@@@@@@@@@@@@@@@@@@
#                  /@@%     .%@@@@@@@@@@@@@@@@@@@@@@@@@@@*            .@@@@@@@@@@       (@@@(  #@@@@           ,/@@@@@@@@
#      &@@@@@     *@@     .    &@       .@@@@@@@@        @#    /@@@.    &@@@@@          .@@@@.      @%     .*.     %@@@@@
#     &@@@@@      @@,   &@@&    @@       /@@@@@@       ,@@%    %@@@@     #@@,     @@@/    #@@@    .@@@     @@@@*    @@@@@
#    &@@@@@      (@@   .@@@@    /@(      ,@@@@@/       (@@*    (@@@@(    ,@@.    @@@@@     %@@    &@@@     @@@@@     &@@@
#   *@@@@@#      @@.   %@@@@    .@(       &@@@@        #@@@    /@@@@.    %@@     @@@@@*    (@@    @@@#     @@@@@#    .@@@
#/ @@@@@@@      @@@    &@@@@     @#       .@@@@        /@@#    (@@@.     @@*     @@@@@     ,@@    %@@@     @@@@@@     @@@
#@@@@@@@@      &@@@    %@@@@     @#        #@@#        ,@@#    ,@@(     @@@     /@@@@@.     @@    #@@@     &@@@@&     @@@
#@@@@@@@      #@@@,    #@@@@     &#        *@@*        .@@@           (@@@@     %@@@@@*     %@    *@@@     (@@@@      %@@
#@@@@@@&     *@@@@,    (@@@@/    @#   .     @%          @@#    (@@@     %@@     &@@@@@@     ,@.   /@@&     /@@@@      /@@
#@@@@@@      %@@@@,    /@@@@    ,@#   %@.        @#    .@@*    %@@@@,    #@     #@@@@@@     %@.   #@@@     (@@@@      ,@@
#@@@@@      *@@@@@@,   /@@@@    (@(   @@/       (@,    ,@@*    #@@@@/    ,@,    /@@@@@      @@    %@@@     @@@@@@     (@@
#@@@@      .@@@@@@@@   .@@@%    /@(   @@@       @@     *@@*    %@@@@     ,@*    ,@@@@@     ,@@    %@@@     @@@@@#     @@@
#@@@@      @@@@@@@( (    #/   .@@@,   (@@.     .@@.    (@@,    &@@@@     (@(    .@@@@@     #@@.   /@@@     @@@@@     #@@@
#@@@      %@@@@@@   /@@.    (@@@@@    .@@@     ,@@(    &@@,    %@@@      @@@    .@@@@@     &@&    .@@&.    @@@@@     @@@@
#@@      /@@@@@@    @@@@@@@@@@@@@@/   .@@@,    %@@     /@             (@@@@@@.   (@@@.     @@.     /@@    ,@@@@     @@@@@
#@      ,@@@@@@     @@@@@@@@@@@@@@    /@@@&   ,@@@     ,@@@@@@@@@@&@@@@@@@@@@@    ,@/    /@@@@@@@@@@@.      /     *@@@@@@
#@      @@@@@@      @@@@@@@@@@@@@      &@@@   @@@(      %@###%.,/###%@((    #@@@,      *@@@@@@@@@@@@@/ ,((,..*/%@@@@@@@@@
#                   &@@@@@@@@@@@@(,(#(*@@@@@@@@@@( ,//*,&@@                     /@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##(*,,. ..,,*****,*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&##                         .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         .%*/@@@( (%#/          /#&( &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     .#(   / .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Please install pip on your system. Use your package maanger if you're using Linux or this if you're using Windows:
# curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
# python get-pip.py
#
#
# python ./main.py (assuming you are positioned in the same folder of the .py file)
#
# Oh, also remember to get a telegram bot TOKEN from the botfather bot and replace the MAIN_TOKEN variable value with it.
# Also make sure your bot is in your public group with admin priviledges and disable the privacy setting of your bot from botfather chat using /setprivacy command or whatever it is.
# I think this should be it...

########################################
### AVOID DOUBLE EXECUTION OF THIS SCRIPT ON THE CURRENT SYSTEM
########################################

def get_pid_and_name():
    import os
    import sys
    return (os.getpid(), os.path.abspath(sys.argv[0]))

def run_command(command):
    import subprocess
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output, error = process.communicate()
        if process.returncode != 0:
            print(f"Error executing command: {error}")
            return None
        return output
    except Exception as e:
        print(f"Error executing command: {e}")
        return None

def is_already_running(current_pid, current_script):
    processes = run_command('ps aux | grep ' + current_script)
    if processes:
        lines = processes.split('\n')
        for line in lines:
            if current_script in line and 'python' in line:
                pid = int(line.split()[1])
                if pid != current_pid:
                    return True
    return False

if __name__ == '__main__':
    try:
        pid, name = get_pid_and_name()
        if is_already_running(pid, name):
            print("Another instance of the script is already running.")
            import sys
            sys.exit(1)
    except Exception as e:
        logger(e, "ERROR")

########################################
### FUNDAMENTAL CONSTANTS
########################################

ALL_CHATS=[-1002033569385]
TOKEN='6353909839:AAEQRzoSX9pXCL0sCtRUiw0aWW4via9bgzU'
SERVICE_NAME ='pzserver'

if __name__ == '__main__':
    try:
        import telebot
        bot = telebot.TeleBot(TOKEN)
    except Exception as e:
        logger(e, "ERROR")

########################################
### BROADCASTER - maybe there's a function already in telbot for this?
########################################

def send_to_all(text, silent=True):
    for each in ALL_CHATS:
        if silent:
            bot.send_message(each, text, disable_notification=True)
        else:
            bot.send_message(each, text)

########################################
### TIMESTAMP FOR OTHER FUNCTIONS
########################################

def log_timestamp():
    from datetime import datetime
    return datetime.now().strftime('[%Y-%m-%d %H:%M:%S]')

def timestamp():
    from datetime import datetime
    return datetime.now()

########################################
### INFORMATION FOR THE LOG FILE
########################################

def log_file():
    import os
    return os.path.join(os.path.abspath(os.path.dirname(__file__)), os.path.splitext(os.path.basename(__file__))[0]+'.log')

def clean_logs(max_rows=1000, buffer=300, log_file=log_file()):
    with open(log_file, 'r') as f:
        lines = f.readlines()
        if len(lines) >= max_rows:
            lines = lines[-(max_rows - buffer):]
        with open(log_file, 'w') as f:
            f.writelines(lines)

def logger(message, msg_type, log_file=log_file()):
    import os
    import traceback
    
    with open(log_file, 'a') as f:
        timestamp = log_timestamp()
        f.write(timestamp+" ["+msg_type+"] "+str(message)+'\n')
        traceback_str = traceback.format_exc()
        if traceback_str:
            f.write(timestamp+"[TRACEBACK] "+traceback_str)

########################################
### STATUS CHECKER
########################################

def check_service_status(service_name=SERVICE_NAME):
    import subprocess
    try:
        # Run systemctl status <service_name> command
        result = subprocess.run(['systemctl', 'status', service_name], capture_output=True, text=True)
        output_lines = result.stdout.split('\n')
        if 'Active: active (running)' in output_lines[2]:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")
        return None

########################################################################################################################
### VOTE FEATURE
########################################################################################################################

def vf_process_serverini(line):
    if line.startswith("#"):
        return (1, line.strip()[2:])
    elif "=" in line:
        line = line.split("=")
        variable, value = line[0].strip(), line[1].strip()
        return (0, (variable, value))
    else:
        return None

def vf_process_sandbox_vars(line):
    if "=" in line:
        if "{" in line:
            return None
        elif "--" in line:
            return (1, line.strip()[3:])
        else:
            line = line.split("=")
            variable, value = line[0].strip(), line[1].strip()[:-1]
            return (0, (variable, value))
    else:
        return None

SERVERINI = ["servertest.ini", "/opt/pzserver/Zomboid/Server/servertest.ini", vf_process_serverini]
SANDBOXVARS = ["servertest_SandboxVars.lua", "/opt/pzserver/Zomboid/Server/servertest_SandboxVars.lua", vf_process_sandbox_vars]

def vf_get_associations(expect='class'):   
    
    global SERVERINI
    global SANDBOXVARS
    setting_files = [SERVERINI, SANDBOXVARS]
    
    class Variable:
        def __init__(self, value, description, file_path, line_number):
            self.value = value
            self.description = description
            self.path = file_path
            self.line = line_number

    class Settings:
        pass

    settings = Settings()
    command_array = []
    
    for basename, file_path, processor in setting_files:
        with open(file_path, 'r') as file:
            description = ""
            line_number=0
            for line in file:
                line_number += 1
                processed = processor(line)
                if processed:
                    is_description, data = processed[0], processed[1]
                    if is_description:
                        description += data + "\n"
                    else:
                        variable, value = data
                        setattr(settings, variable, Variable(value, description, file_path, line_number))
                        command_array.append((variable, value, description, file_path, line_number))
                        #print("section: "+basename); print(variable+": "+value); print(description); print("-------------------------")
                        description = ""
    if expect == 'class':
        return settings
    elif expect == 'array':
        return command_array
    elif expect == 'both':
        return (settings,command_array)
    else:
        return None

########################################
### SETTINGS MANAGER
########################################

global_settings = vf_get_associations()
pending_changes = []

def reload_settings():
    global global_settings
    global_settings = vf_get_associations()

def changes_are_applied():
    reload_settings()
    global pending_changes
    failed=[]
    for variable, new_value, path, line in pending_changes:
        if getattr(global_settings, variable).value == new_value:
            pass
        else:
            failed.append([variable, new_value, path, line])
            logger("This change failed to commit. Invalid Setting? "+str([variable, new_value, path, line]), "WARNING", log_file())
            return False
    pending_changes = failed
    return True

def save_setting_to_file(setting, value):
    with open(getattr(global_settings, setting).path, 'r+') as file:
        all_lines = file.readlines()
        line = all_lines[getattr(global_settings, setting).line -1]
        if setting in line:
            all_lines[getattr(global_settings, setting).line -1] = line.replace(getattr(global_settings, setting).value, value)
            file.seek(0)
            file.writelines(lines)
            return True
        return False

def is_setting(setting):
    if hasattr(global_settings, setting):
        return True
    else:
        return False

def get_setting(setting):
    if hasattr(global_settings, setting):
        return getattr(global_settings, setting).value
    else:
        return Exception

def get_setting_desc(setting):
    if hasattr(global_settings, setting):
        return getattr(global_settings, setting).description
    else:
        return Exception

def set_setting(setting, value):
    if hasattr(global_settings, setting):
        save_setting_to_file(setting, value)
        global pending_changes
        pending_changes.append([setting, getattr(global_settings, setting).value, getattr(global_settings, setting).path, getattr(global_settings, setting).line])
        reload_settings()
        return True
    else:
        return None
    
########################################
### MOD MANAGER #mod_url="https://steamcommunity.com/sharedfiles/filedetails/?id="+workshop_id
########################################

def is_modid(mod_id):
    return (char.isalnum() or char == '_' for char in mod_id)

def is_workshopid(workshop_id):
    return (char.isdigit() for char in workshop_id and len(workshop_id) == 10)

def are_valid_IDs(id1, id2):
    if is_workshopid(id1):
        if is_modid(id2):
            return[id2,id1]
        else:
            return False
    elif is_workshopid(id2):
        if is_modid(id1):
            return[id1,id2]
        else:
            return False
    else:
        return False

def get_mod_and_workshopid_list():
    return ((get_setting('Mods').split(','), get_setting('WorkshopItems').split(',')))

def mod_is_installed(id1, id2):
    valid = are_valid_IDs(id1, id2)
    if valid:
        modid, workshopid = valid
        mod_list, workshop_list = get_mod_and_workshopid_list()
        if modid in mod_list and workshopid in workshop_list:
            if mod_list.index(modid) == workshop_list.index(workshopid):
                return True
            else:
                logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted installed but are not at the same position in config file. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING", log_file()) #This case might be a hint for issues in loading mods in game
                return False
        elif modid not in mod_list and workshopid not in workshop_list:
            return False
        else:
            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted being only partially present in file. Probably a typo of the user who entered these IDs? If mods are being loaded correctly, you can safely ignore this warning.", "WARNING", log_file()) #This case might be a hint for issues in loading mods in game
            return False
    else:
        logger("Mod IDs entered in chat ("+modid+", "+workshopid+") are invalid. Are you having fun or typo?", "WARNING", log_file())
        return False

def check_modid_list(modid_list):
    if not modid_list:
        return True  # Empty string is allowed
    modid_list = modid_list.split(',')
    return all(all(is_modid(modid)) for modid in modid_list)

def check_workshopid_list(workshopid_list):
    if not workshopid_list:
        return True  # Empty string is allowed
    modid_list = workshopid_list.split(',')
    return all(all(is_workshopid(modid)) for modid in modid_list)

def list_mod(message):
    workshopids=get_setting('WorkshopItems').split(',')
    if len(workshopids) == 0:
        bot.reply_to(message, "The mod list is empty", disable_notification=True)
    else:
        for mod in workshopids:
            bot.reply_to(message, "https://steamcommunity.com/sharedfiles/filedetails/?id="+mod, disable_notification=True)
            
def install_mod(modid, workshopid):
    modids=get_setting('Mods')
    workshopids=get_setting('WorkshopItems')
    set_setting('Mods', modids+","+modid)
    set_setting('WorkshopItems', modids+","+workshopid)

def uninstall_mod(modid, workshopid):
    modids=get_setting('Mods')
    workshopids=get_setting('WorkshopItems')
    new_modid_list=get_setting('Mods').replace(modid, "").replace(",,", "")
    new_workshopid_list=set_setting(get_setting('WorkshopItems').replace(workshopid, "").replace(",,", ""))
    #MODIDS
    if new_modid_list.endswith(","):
        new_modid_list=new_modid_list[:-1]
    elif new_mod_list.beginswith(","):
        new_modid_list=new_modid_list[1:]
    #WORKSHOPIDS
    if new_workshopid_list.endswith(","):
        new_workshopid_list=new_workshopid_list[:-1]
    elif new_workshopid_list.beginswith(","):
        new_workshopid_list=new_workshopid_list[1:]
    #FINAL CHECK
    if check_modid_list and check_workshopid_list:
        set_setting('Mods', new_modid_list)
        set_setting('WorkshopItems', new_workshopid_list)

########################################################################################################################
### PARSING FEATURE
########################################################################################################################

### PARSING FLAGS & CONSTANTS

command_flag = True
join_flag = True
left_flag = True
pzserver_log_path = '/opt/pzserver/pzserver.log'

pzserver_log_keywork_start = 'Zomboid Server is VAC Secure'
pzserver_log_keywork_stop = 'command entered via server console (System.in): "quit"'
pzserver_log_keywork_login = 'BUpdateUserData'
pzserver_log_keywork_logout = 'CloseConnection: Finally disconnected'
pzserver_log_keywork_cmd = 'command entered'

global_association_table = []

### PARSING FUNCTIONS

def alert_bot(keyword, line):
    try:
        import re
        if keyword == pzserver_log_keywork_start:
            send_to_all(SERVICE_NAME.capitalize()+" is now online.")
            if not changes_are_applied():
                send_to_all("Seems like some changes were not applied since last reboot. Check logs for more info.")
        elif keyword == pzserver_log_keywork_stop:
            send_to_all(SERVICE_NAME.capitalize()+" is going down...")
        elif command_flag and keyword == pzserver_log_keywork_cmd:
            if '"quit"' not in line and '"save"' not in line:
                send_to_all("A"+line[44:])
        elif join_flag and keyword == pzserver_log_keywork_login:
            pattern_username = r"'(.*?)'"
            username = re.search(pattern_username, line).group(1)
            pattern_steamid = r"id=(\d+)"
            steamid = re.search(pattern_steamid, line).group(1)
            left = False
            found = False
            for each in global_association_table:
                if each[0] == steamid:
                    if each[2] == 1:
                        left = True
                        each[2] = 0
                    found = True
            if left or not found:
                send_to_all("A player connected to the server: "+username)
            if not found:
                global_association_table.append([steamid, username, 0])
        elif left_flag and keyword == pzserver_log_keywork_logout:
            pattern_steamid = r"SteamID=(\d+)"
            steamid = re.search(pattern_steamid, line).group(1)
            username = False
            for each in global_association_table:
                if each[0] == steamid:
                    each[2] = 1
                    username = each[1]
            if not username:
                username = steamid
            send_to_all("A player left the server: "+username)
    except Exception as e:
        logger(e, "ERROR")

def monitor_log(filename=pzserver_log_path, keywords=[pzserver_log_keywork_start,pzserver_log_keywork_stop,pzserver_log_keywork_login,pzserver_log_keywork_logout,pzserver_log_keywork_cmd]):
    import time
    try:
        with open(filename, 'r') as f:
            f.seek(0, 2)
            while True:
                current_position = f.tell()
                line = f.readline()
                if not line:
                    time.sleep(0.1)
                    f.seek(current_position)
                else:
                    for keyword in keywords: 
                        if keyword in line:
                            alert_bot(keyword, line)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### COMMAND SETUP & COMMAND RELATED
########################################################################################################################

### COMMANDS - FUNCTIONS

def add_cmd(command_list, cmd, description):
    from telebot import types
    print("CMD: "+cmd+" ("+str(len(cmd))+")")
    print("DESC: "+description+" ("+str(len(description))+")\n")
    command_list.append(types.BotCommand(command=str(cmd), description=str(description)))
    return True

def add_cmd_bulk(command_list, cmd_list):
    from telebot import types
    for cmd, description in cmd_list:
        add_cmd(command_list, cmd, description)

def init_commands():
    command_list = []
    return add_cmd_bulk(command_list, [[start_cmd,start_desc],[restart_cmd,restart_desc],[status_cmd,status_desc],[mod_cmd,mod_desc],[setting_cmd,setting_desc],[help_cmd,help_desc]])
    
### COMMAND - MESSAGES

start_cmd='start'
start_desc='Display bot welcome message.'
start_msg='Hi, I am Rotting Ghoul! I can automatically get you updates on the status of the PZserver.'
restart_cmd='restart'
restart_confirm_cmd='confirm_restart'
restart_cancel_cmd='cancel_restart'
restart_desc='Restart the application'
restart_msg="Are you really sure you want to restart the server? All users will be disconnected.\n\nPlease press: /"+restart_confirm_cmd+" to proceed.\n\nOr press: /"+restart_cancel_cmd+" to cancel."
status_cmd='status'
status_desc='Retrive the current status of '+SERVICE_NAME
mod_cmd='mod'
mod_desc='Allows to manage installed mods through vote'
mod_msg_helper='''
Please use:
        /'''+mod_cmd+''' list
        /'''+mod_cmd+''' install <Workshop ID> <Mod ID>
        /'''+mod_cmd+''' uninstall <Mod ID> OR <Workshop ID>'''
setting_cmd='setting'
setting_desc='Allows to manage server settings through vote'
setting_msg_helper='''
Please use:
        /'''+setting_cmd+''' get <any parameter>
        /'''+setting_cmd+''' set <any parameter>'''
help_cmd='help'
help_desc='Provide the command legenda.'
help_msg="List of the commands:\n/"+help_cmd+": "+help_desc+"\n/"+status_cmd+": "+status_desc+"\n/"+restart_cmd+": "+restart_desc+"\n/"+mod_cmd+": "+mod_msg_helper+"\n/"+setting_cmd+": "+setting_msg_helper

### COMMANDS - RESTART DOUBLE CHECK - no database, just memory

global_restart_requests = []

def save_restart(restart_cmd, user):
    global global_restart_requests
    for each in global_restart_requests:
        if each[1] == user:
            each[0] = cmd
            return
    global_restart_requests.append((cmd, user))        

def check_restart(restart_cmd, user):
    global global_restart_requests
    for each in global_restart_requests:
        if each[0] == cmd and each[1] == user:
            return True
    return False

def clear_restart(user):
    global global_restart_requests
    temp = global_restart_requests
    for each in global_restart_requests:
        if each[1] == user:
            temp.remove(each)
            removed = True
    global_restart_requests = temp
    print(global_restart_requests)
    if removed:
        return True
    else:
        return False

########################################################################################################################
### MAIN
########################################################################################################################

if __name__ == '__main__':
    try:
        ########################################
        ### INITIALIZATION
        ########################################

        # KEEP LOGS SHORTER THAN MAXIMUM LENGHT
        clean_logs()
        # SETUP COMMANDS
        commands = init_commands()
        if commands:
            print(commands)
            bot.set_my_commands(commands)

        ########################################
        ### TOOLS
        ########################################

        def member_is_admin(message):
            member = bot.get_chat_member(message.chat.id, message.from_user.id)
            if member.status in ['creator','administrator']:
                return True
            else:
                bot.reply_to(message, "This command requires administrator-level or superior priviledges.", disable_notification=True)
                return False
        
        ########################################
        ### SETUP LOG PARSING FUNCTION
        ########################################
        
        import threading
        poll_monitor_log_thread = threading.Thread(target=monitor_log)
        poll_monitor_log_thread.start()
        
        ########################################
        ### SETUP VOTE FUNCTIONS
        ########################################
        
        class Reform:
            def __init__(self, proposer, userid, chatid, poll, date, ctype, change):
                self.uid = uid
                self.proposer = proposer
                self.userid = userid
                self.chatid = chatid
                self.name = name
                self.poll = poll
                self.date = date
                self.ctype = ctype
                self.change = change

        class Change_Mod:
            def __init__(self, modid, workshopid, action):
                self.ctype = 'mod'
                self.action = action
                self.modid = modid
                self.workshopid = workshopid

        class Change_Setting:
            def __init__(self, variable, value, path):
                self.ctype = 'setting'
                self.variable = variable
                self.value = value
        
        monitoranda=[]
        stop_monitoring_after = 8 #days

        def create_poll(chat_id, description, options, anonymous=False, multiple_answers=False):
            reply_markup = {"type": "inline", "inline_keyboard": [[{"text": option, "callback_data": option} for option in options]]}
            return bot.send_Poll(chat_id, question=description, options=options, is_anonymous=anonymous, allows_multiple_answers=multiple_answers, reply_markup=reply_markup)

        def create_reform(proposer, userid, chat_id, ctype, change):
            if ctype == 'mod':
                action, modid, workshopid = change
                new_reform = Reform
                new_reform.uid = ""#random string to use to indetify the reform later
                new_reform.proposer = proposer
                new_reform.userid = userid
                new_reform.chatid = chat_id
                new_reform.name = f"{action} {modid} [https://steamcommunity.com/sharedfiles/filedetails/?id={workshop_id}]"
                new_reform.date = timestamp()
                new_reform.ctype = ctype
                new_reform.change = Change_Mod
                new_reform.change.action = action
                new_reform.change.modid = modid
                new_reform.change.workshopid = workshopid
                new_reform.poll = create_poll(chat_id, new_reform.name, ['Yes','No'])
            elif ctype == 'setting':
                variable, value = change
                new_reform = Reform
                new_reform.uid = ""#random string to use to indetify the reform later
                new_reform.proposer = proposer
                new_reform.userid = userid
                new_reform.chatid = chat_id
                new_reform.name = f"set {variable} = {value}"
                new_reform.date = timestamp()
                new_reform.ctype = ctype
                new_reform.change = Change_Setting
                new_reform.change.variable = variable
                new_reform.change.value = value
                new_reform.poll = create_poll(chat_id, new_reform.name, ['Yes','No'])
            return new_reform.poll.message_id

        def commit_change(reform_change):
            if change.ctype == 'mod':
                if change.action == 'install':
                    install_mod(modid, workshopid)
                elif change.action == 'uninstall':
                    uninstall_mod(modid, workshopid)
                logger(f"Type: {change.ctype} Action: {change.action} ModID: {change.modid} WorkshopID: {change.workshopid} Date: {log_timestamp}", log_file())
            elif change.ctype == 'setting':
                logger(f"Type: {change.ctype} Variable: {change.variable} Old Value: {get_setting(change.variable)} New Value: {change.value} Date: {log_timestamp}", log_file())
                set_setting(change.variable, change.value)

        def consensus(poll):
            threshold = bot.get_chat_members_count(poll.chat_id) // 2 + 1  # Majority threshold
            return (max(option.voter_count for option in poll.options) >= threshold)

        def poll_monitor(reform):
            while timestamp() - days_passed >= stop_monitoring_after:
                if consensus(reform.poll):
                    bot.stop_poll(reform.poll.chat.id, reform.poll.message_id)
                    commit_change(reform.change)
                    monitoranda.remove(reform)
                    break
            else:
                monitoranda.remove(reform)
        
        def start_monitoring(reforms_to_be_monitored):
            for reform in reforms_to_be_monitored:
                poll_monitor_thread = threading.Thread(target=poll_monitor(reform.poll))
                poll_monitor_thread.start()
        
        start_monitoring(monitoranda)
        
        ########################################
        ### TELEBOT - COMMAND HANDLERS
        ########################################
        
        # START
        @bot.message_handler(commands=[start_cmd])
        def send_start(message):
            bot.reply_to(message, start_msg, disable_notification=True)
        # HELP
        @bot.message_handler(commands=[help_cmd])
        def send_help(message):
            bot.reply_to(message, help_msg, disable_notification=True)
        # STATUS
        @bot.message_handler(commands=[status_cmd])
        def send_status(message):
            service_status = check_service_status()
            if service_status:
                status = "active."
            elif not service_status:
                status = "down."
            else:
                status = "???"
            bot.reply_to(message, "The PZserver is currently "+status)
        # RESTART
        @bot.message_handler(commands=[restart_cmd])
        def restart_server(message):
            is_admin = member_is_admin(message)
            if is_admin:
                if check_service_status():
                    save_restart(restart_cmd, message.from_user.id)
                    print(global_commands)
                    bot.reply_to(message, restart_msg, disable_notification=True)
                else:
                    bot.reply_to(message, "The server is currently down.", disable_notification=True)
        @bot.message_handler(commands=[restart_confirm_cmd])
        def confirm_restart(message):
            restart_required = check_restart(restart_cmd, message.from_user.id)
            if restart_required:
                clear_restart(message.from_user.id)
                run_command("sudo systemctl restart " + get_servicename())
        @bot.message_handler(commands=[restart_cancel_cmd])
        def cancel_restart(message):
            clear_restart(message.from_user.id)
        # MOD INSTALL / UNINSTALL
        @bot.message_handler(commands=[mod_cmd])
        def mod_command(message):
            command = message.text.split()
            if command[1] == 'list':
                if len(command) == 2:
                    list_mod(message)
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            elif command[1] == 'install':
                if len(command) == 4:
                    installed = mod_is_installed(command[2], command[3])
                    if installed:
                        modid, workshopid = installed
                        bot.reply_to(message, "The mod you want to install is already installed. Is there a issue related to mod loading perhaps?", disable_notification=True)
                    else:
                        create_reform(f"{message.from_user.first_name} {message.from_user.last_name}", message.from_user.id, message.chat.id, 'mod', 'install', modid, workshopid)
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            elif command[1] == 'uninstall':
                if len(command) == 3:
                    installed = mod_is_installed(command[2])
                    if installed:
                        modid, workshopid = installed
                        create_reform(f"{message.from_user.first_name} {message.from_user.last_name}", message.from_user.id, message.chat.id, 'mod', ['uninstall', modid, workshopid])
                elif len(command) == 4:
                    installed = mod_is_installed(command[2], command[3])
                    if installed:
                        modid, workshopid = installed
                        create_reform(f"{message.from_user.first_name} {message.from_user.last_name}", message.from_user.id, message.chat.id, 'mod', ['install', modid, workshopid])
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            else:
                bot.reply_to(message, mod_msg_helper, disable_notification=True)
        # MODIFY PZSERVER SETTINGS
        @bot.message_handler(commands=[setting_cmd])
        def setting_command(message):
            command = message.text.split()
            if command[1] == "get":
                if len(command) == 3:
                    if is_setting(command[2]):
                        bot.reply_to(message, get_setting(command[2]), disable_notification=True)
                        bot.reply_to(message, get_setting_desc(command[2]), disable_notification=True)
                    else:
                        bot.reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?", disable_notification=True)
                else:
                    bot.reply_to(message, setting_msg_helper, disable_notification=True)
            elif command[1] == "set":
                if len(command) == 4:
                    if is_setting(command[2]):
                        create_reform(f"{message.from_user.first_name} {message.from_user.last_name}", message.from_user.id, message.chat.id, 'setting', [command[2], command[3]])
                    else:
                        bot.reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?", disable_notification=True)
                else:
                    bot.reply_to(message, setting_msg_helper, disable_notification=True)
            else:
                bot.reply_to(message, setting_msg_helper, disable_notification=True)
        
        ########################################
        ### TELEBOT - START POLLING
        ########################################
        
        bot.infinity_polling()
        
    except Exception as e:
        logger(e, "ERROR")
