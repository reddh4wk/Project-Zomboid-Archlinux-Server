#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    @@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  ,@@@@@@@@@@@@@@@@@@@@@  @@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@%        @@       @@      @@   /@@&     .@@@     #%    /@@@@  .      @@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@%  /@@  .@&  #@@@@  ,@@,  @&  /@@  .@@  /@.  @@@@@@  *@@@@@, @@      @@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  /@@  ,@@  #@@@%  *@@   @@  (@&  ,@@@@@@  .@@@@@@  *@@@@@  @.    ,&*@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  ,@@  #@@  #@@@@, .@@  #@@  (@@*  @@@(/@(  @@@ /@  *@@@@@@%   (. .@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@.  /@@@@@@@@@@@@@@@@@@@@@#@%  %@@@@@@@@@@@@@@@@@@@@@@@@@@@@,  .@@%  @@@@@@@@@@@@@@@@@@@@@@@@@
#@                 @@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@&&&@@@@@@@@@@@@@@@@@@   (@@@  (@@@@@@@@@@@@@@@@@@@@@@@@@
#                  /@@%     .%@@@@@@@@@@@@@@@@@@@@@@@@@@@*            .@@@@@@@@@@       (@@@(  #@@@@           ,/@@@@@@@@
#      &@@@@@     *@@     .    &@       .@@@@@@@@        @#    /@@@.    &@@@@@          .@@@@.      @%     .*.     %@@@@@
#     &@@@@@      @@,   &@@&    @@       /@@@@@@       ,@@%    %@@@@     #@@,     @@@/    #@@@    .@@@     @@@@*    @@@@@
#    &@@@@@      (@@   .@@@@    /@(      ,@@@@@/       (@@*    (@@@@(    ,@@.    @@@@@     %@@    &@@@     @@@@@     &@@@
#   *@@@@@#      @@.   %@@@@    .@(       &@@@@        #@@@    /@@@@.    %@@     @@@@@*    (@@    @@@#     @@@@@#    .@@@
#/ @@@@@@@      @@@    &@@@@     @#       .@@@@        /@@#    (@@@.     @@*     @@@@@     ,@@    %@@@     @@@@@@     @@@
#@@@@@@@@      &@@@    %@@@@     @#        #@@#        ,@@#    ,@@(     @@@     /@@@@@.     @@    #@@@     &@@@@&     @@@
#@@@@@@@      #@@@,    #@@@@     &#        *@@*        .@@@           (@@@@     %@@@@@*     %@    *@@@     (@@@@      %@@
#@@@@@@&     *@@@@,    (@@@@/    @#   .     @%          @@#    (@@@     %@@     &@@@@@@     ,@.   /@@&     /@@@@      /@@
#@@@@@@      %@@@@,    /@@@@    ,@#   %@.        @#    .@@*    %@@@@,    #@     #@@@@@@     %@.   #@@@     (@@@@      ,@@
#@@@@@      *@@@@@@,   /@@@@    (@(   @@/       (@,    ,@@*    #@@@@/    ,@,    /@@@@@      @@    %@@@     @@@@@@     (@@
#@@@@      .@@@@@@@@   .@@@%    /@(   @@@       @@     *@@*    %@@@@     ,@*    ,@@@@@     ,@@    %@@@     @@@@@#     @@@
#@@@@      @@@@@@@( (    #/   .@@@,   (@@.     .@@.    (@@,    &@@@@     (@(    .@@@@@     #@@.   /@@@     @@@@@     #@@@
#@@@      %@@@@@@   /@@.    (@@@@@    .@@@     ,@@(    &@@,    %@@@      @@@    .@@@@@     &@&    .@@&.    @@@@@     @@@@
#@@      /@@@@@@    @@@@@@@@@@@@@@/   .@@@,    %@@     /@             (@@@@@@.   (@@@.     @@.     /@@    ,@@@@     @@@@@
#@      ,@@@@@@     @@@@@@@@@@@@@@    /@@@&   ,@@@     ,@@@@@@@@@@&@@@@@@@@@@@    ,@/    /@@@@@@@@@@@.      /     *@@@@@@
#@      @@@@@@      @@@@@@@@@@@@@      &@@@   @@@(      %@###%.,/###%@((    #@@@,      *@@@@@@@@@@@@@/ ,((,..*/%@@@@@@@@@
#                   &@@@@@@@@@@@@(,(#(*@@@@@@@@@@( ,//*,&@@                     /@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##(*,,. ..,,*****,*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&##                         .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         .%*/@@@( (%#/          /#&( &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     .#(   / .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Please install pip on your system. Use your package maanger if you're using Linux or this if you're using Windows:
# curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
# python get-pip.py
#
#
# python ./main.py (assuming you are positioned in the same folder of the .py file)
#
# Oh, also remember to get a telegram bot TOKEN from the botfather bot and replace the MAIN_TOKEN variable value with it.
# Also make sure your bot is in your public group with admin priviledges and disable the privacy setting of your bot from botfather chat using /setprivacy command or whatever it is.
# I think this should be it...

########################################
### FUNDAMENTAL CONSTANTS
########################################

ALL_CHATS=[-1002033569385]
TOKEN='6353909839:AAEQRzoSX9pXCL0sCtRUiw0aWW4via9bgzU'
SERVICE_NAME ='pzserver'

########################################################################################################################
### INFORMATION FOR THE LOG FILE
########################################################################################################################

def log_timestamp():
    from datetime import datetime
    return datetime.now().strftime('[%Y-%m-%d %H:%M:%S]')

def log_file():
    import os
    return os.path.join(os.path.abspath(os.path.dirname(__file__)), os.path.splitext(os.path.basename(__file__))[0]+'.log')

def logger(message, msg_type, log_file=log_file()):
    import os
    import traceback
    with open(log_file, 'a') as f:
        timestamp = log_timestamp()
        f.write(timestamp+" ["+msg_type+"] "+str(message)+'\n')
        traceback_str = traceback.format_exc()
        if msg_type == 'ERROR':
            if traceback_str:
                f.write(timestamp+"[TRACEBACK] "+traceback_str)

def log_emendazio(max_rows=1000, buffer=300, log_file=log_file()):
    try:
        with open(log_file, 'r') as f:
                lines = f.readlines()
                if len(lines) >= max_rows:
                    lines = lines[-(max_rows - buffer):]
                with open(log_file, 'w') as f:
                    f.writelines(lines)
    except Exception as e:
        logger(e, "ERROR")
        return None

########################################################################################################################
### USEFUL TOOLS
########################################################################################################################

def timestamp():
    from datetime import datetime
    return datetime.now()

def unix_timestamp():
    import time
    return int(time.time())

def unix_timestamp_to_log_timestamp(unix_timestamp):
    from datetime import datetime
    return datetime.utcfromtimestamp(unix_timestamp).strftime('[%Y-%m-%d %H:%M:%S]')
    
def run_command(command):
    import subprocess
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output, error = process.communicate()
        if process.returncode != 0:
            logger(error, "OS ERROR")
            return None
        return output
    except Exception as e:
        logger(e, "ERROR")

def check_service_status(service_name=SERVICE_NAME):
    import subprocess
    try:
        if 'Active: active (running)' in run_command('systemctl status '+SERVICE_NAME).split('\n')[2]:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")
        return None

def strip_img_url_from_steam(workshop_url):
    try:
        img_url = run_command("curl -kl "+workshop_url+" | grep \"steamuserimages-a.akamaihd.net/ugc\" | egrep -v \"property|twitter\" | grep \"letterbox=true\" | head -1 | awk \'{print $2}\'").split("?")[0][1:]
        logger(f"A image url has been stripped from steam workshop: {img_url}", "INFO")
        return img_url
    except Exception as e:
        logger(e, "ERROR")

def is_workshop_url(url):
    try:
        import re
        pattern = r"https:\/\/steamcommunity\.com\/sharedfiles\/filedetails\/\?id=\d+"
        if re.match(pattern, url):
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def strip_IDs_from_steam(url):
    try:
        import requests
        import re
        response = requests.get(url)
        if response.status_code == 200:
            source_code = response.text
            match = re.search(r"Mod ID:\s*([a-zA-Z0-9_()]+)", source_code)
            if match:
                mod_id = match.group(1)
                return is_modid_workshopid(mod_id, url.split('=')[1])
            return False
        else:
            logger(f"Failed to fetch page. Status code: {str(response.status_code)}", "ERROR")
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### AVOID DOUBLE EXECUTION OF THIS SCRIPT ON THE CURRENT SYSTEM
########################################################################################################################

def get_pid_and_name():
    import os
    import sys
    try:
        return (os.getpid(), os.path.abspath(sys.argv[0]))
    except Exception as e:
        logger(e, "ERROR")

def is_already_running(current_pid, current_script):
    try:
        processes = run_command('ps aux | grep ' + current_script)
        if processes:
            lines = processes.split('\n')
            for line in lines:
                if current_script in line and 'python' in line:
                    pid = int(line.split()[1])
                    if pid != current_pid:
                        return True
        return False
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        pid, name = get_pid_and_name()
        if is_already_running(pid, name):
            print("Another instance of the script is already running.")
            import sys
            sys.exit(1)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### SERVER SETTINGS
########################################################################################################################

def process_serverini(line):
    try:
        if line.startswith("#"):
            return (1, line.strip()[2:])
        elif "=" in line:
            line = line.split("=")
            variable, value = line[0].strip(), line[1].strip()
            return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def process_sandbox_vars(line):
    try:
        if "=" in line:
            if "{" in line:
                return None
            elif "--" in line:
                return (1, line.strip()[3:])
            else:
                line = line.split("=")
                variable, value = line[0].strip(), line[1].strip()[:-1]
                return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

SERVERINI = ["servertest.ini", "/opt/pzserver/Zomboid/Server/servertest.ini", process_serverini]
SANDBOXVARS = ["servertest_SandboxVars.lua", "/opt/pzserver/Zomboid/Server/servertest_SandboxVars.lua", process_sandbox_vars]

def get_settings():
    try:
        global SERVERINI
        global SANDBOXVARS
        setting_files = [SERVERINI, SANDBOXVARS]
        class Variable:
            def __init__(self, value, description, file_path, line_number):
                self.value = value
                self.description = description
                self.path = file_path
                self.line = line_number
        class Settings:
            pass
        settings = Settings()
        for basename, file_path, processor in setting_files:
            with open(file_path, 'r') as file:
                description = ""
                line_number=0
                for line in file:
                    processed = processor(line)
                    if processed:
                        is_description, data = processed[0], processed[1]
                        if is_description:
                            description += data + "\n"
                        else:
                            variable, value = data
                            setattr(settings, variable, Variable(value, description, file_path, line_number))
                            #print("section: "+basename); print(variable+": "+value); print(description); print("-------------------------")
                            description = ""
                    line_number += 1
        return settings
    except Exception as e:
        logger(e, "ERROR")

global_settings = get_settings()

########################################
### SETTINGS MANAGERS
########################################

def reload_settings():
    try:
        global global_settings
        global_settings = get_settings()
    except Exception as e:
        logger(e, "ERROR")

def changes_are_applied():
    try:
        reload_settings()
        global pending_changes
        failed=[]
        for variable, new_value, path, line in pending_changes:
            if getattr(global_settings, variable).value == new_value:
                pass
            else:
                failed.append([variable, new_value, path, line])
                logger("This change failed to commit. Invalid Setting? "+str([variable, new_value, path, line]), "WARNING", log_file())
                return False
        pending_changes = failed
        return True
    except Exception as e:
        logger(e, "ERROR")

def setting_timestamp():
    try:
        pass
    except Exception as e:
        logger(e, "ERROR")

def save_setting_to_file(setting, value):
    try:
        with open(getattr(global_settings, setting).path, 'r+') as file:
            all_lines = file.readlines()
            line = all_lines[getattr(global_settings, setting).line]
            if setting in line:
                all_lines[getattr(global_settings, setting).line] = line.replace(getattr(global_settings, setting).value, value)
                file.seek(0)
                file.writelines(lines)
                return True
            return False
    except Exception as e:
        logger(e, "ERROR")

def is_setting(setting):
    try:
        return hasattr(global_settings, setting)
    except Exception as e:
        logger(e, "ERROR")

def get_setting(setting):
    try:
        if hasattr(global_settings, setting):
            return getattr(global_settings, setting)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def set_setting_value(setting, value):
    try:
        if hasattr(global_settings, setting):
            if save_setting_to_file(setting, value):
                reload_settings()
                return True
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################
### MOD MANAGER & TOOLS
########################################

def is_modid(mod_id):
    try:
        return (char.isalnum() or char == '_' for char in mod_id)
    except Exception as e:
        logger(e, "ERROR")

def is_workshopid(workshop_id):
    try:
        return all(char.isdigit() for char in workshop_id) and len(workshop_id) == 10
    except Exception as e:
        logger(e, "ERROR")

def is_modid_workshopid(id1, id2):
    try:
        if is_workshopid(id1):
            if is_modid(id2):
                return[id2,id1]
            else:
                return False
        elif is_workshopid(id2):
            if is_modid(id1):
                return[id1,id2]
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def get_mod_and_workshopid_list():
    try:
        return ((get_setting('Mods').value.split(','), get_setting('WorkshopItems').value.split(',')))
    except Exception as e:
        logger(e, "ERROR")

def mod_is_installed(id1, id2):
    try:
        valid = is_modid_workshopid(id1, id2)
        if valid:
            modid, workshopid = valid
            mod_list, workshop_list = get_mod_and_workshopid_list()
            if modid in mod_list and workshopid in workshop_list:
                if mod_list.index(modid) == workshop_list.index(workshopid):
                    return True
                else:
                    logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted installed but are not at the same position in config file. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING", log_file()) #This case might be a hint for issues in loading mods in game
                    return False
            elif modid not in mod_list and workshopid not in workshop_list:
                return False
            else:
                logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted being only partially present in file. Probably a typo of the user who entered these IDs? If mods are being loaded correctly, you can safely ignore this warning.", "WARNING", log_file()) #This case might be a hint for issues in loading mods in game
                return False
        else:
            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") are invalid. Are you having fun or typo?", "WARNING", log_file())
            return False
    except Exception as e:
        logger(e, "ERROR")

def valid_modid_list(modid_list):
    try:
        if not modid_list:
            return True  # Empty string is allowed
        modid_list = modid_list.split(';')
        return all(all(is_modid(modid)) for modid in modid_list)
    except Exception as e:
        logger(e, "ERROR")

def valid_workshopid_list(workshopid_list):
    try:
        if not workshopid_list:
            return True  # Empty string is allowed
        modid_list = workshopid_list.split(',')
        return all(all(is_workshopid(modid)) for modid in modid_list)
    except Exception as e:
        logger(e, "ERROR")
           
def install_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modids=get_setting(modid_setting).value
        workshopids=get_setting(workshopid_setting).value
        set_setting_value(modid_setting, modids+","+modid)
        set_setting_value(workshopid_setting, modids+","+workshopid)
    except Exception as e:
        logger(e, "ERROR")

def uninstall_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modids=get_setting(modid_setting).value
        workshopids=get_setting(workshopid_setting).value
        new_modid_list=get_setting(modid_setting).value.replace(modid, "").replace(",,", "")
        new_workshopid_list=set_setting_value(get_setting(workshopid_setting).value.replace(workshopid, "").replace(",,", ""))
        #MODIDS
        if new_modid_list.endswith(","):
            new_modid_list=new_modid_list[:-1]
        elif new_mod_list.beginswith(","):
            new_modid_list=new_modid_list[1:]
        #WORKSHOPIDS
        if new_workshopid_list.endswith(","):
            new_workshopid_list=new_workshopid_list[:-1]
        elif new_workshopid_list.beginswith(","):
            new_workshopid_list=new_workshopid_list[1:]
        #FINAL CHECK
        if valid_modid_list and valid_workshopid_list:
            set_setting_value('Mods', new_modid_list)
            set_setting_value('WorkshopItems', new_workshopid_list)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### DATABASES PLAYGROUND
########################################################################################################################

reforms_db = 'reforms.db'
players_db = 'players.db'

# TO CREATE SETTINGS BACKUPS
def selfcreate_sqlite_table(table_name, **kwargs):
    import sqlite3
    import os
    try:
        if len(kwargs) < 1:
            return
        db_file = f"{table_name}.db"
        db_path = os.path.join(os.path.dirname(__file__), db_file)
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        pk = list(kwargs.keys())[0]
        columns = []
        for key, value in kwargs.items():
            valid_types = [int, float, str]
            if type(value) not in valid_types:
                print(f"Unsupported type for column '{key}'")
                return False
            sqlite_type = {int: "INTEGER", float: "REAL", str: "TEXT"}[type(value)]
            if key == pk:
                columns.append(f"{key} {sqlite_type} PRIMARY KEY")
            else:
                columns.append(f"{key} {sqlite_type}")
        if len(columns) < 1:
            print("No valid columns provided")
            return False
        create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
        print(create_table_sql)
        c.execute(create_table_sql)
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Reform:
    def __init__(self, reform_id=None, reform_chat_id=None, reform_name=None, reform_description=None, reform_date=None, reform_implemented=None,
                poll_id=None, poll_is_boolean=None, poll_max_voters_number=None,poll_consensus_coefficient=None, poll_active_time=None, poll_yes_list=None, poll_no_list=None,
                change_ctype=None, change_mod_action=None, change_mod_modid=None, change_mod_workshopid=None, change_setting_variable=None, change_setting_old_value=None, change_setting_new_value=None,
                proposer_first_name=None, proposer_last_name=None, proposer_username=None, proposer_id=None):
        self.reform_id = reform_id
        self.reform_chat_id = reform_chat_id
        self.reform_name = reform_name
        self.reform_description = reform_description
        self.reform_date = reform_date
        self.reform_implemented = reform_implemented
        self.poll_id = poll_id
        self.poll_max_voters_number = poll_max_voters_number
        self.poll_consensus_coefficient = poll_consensus_coefficient
        self.poll_active_time = poll_active_time
        self.poll_yes_list = poll_yes_list
        self.poll_no_list = poll_no_list
        self.change_ctype = change_ctype
        self.change_mod_action = change_mod_action
        self.change_mod_modid = change_mod_modid
        self.change_mod_workshopid = change_mod_workshopid
        self.change_setting_variable = change_setting_variable
        self.change_setting_old_value = change_setting_old_value
        self.change_setting_new_value = change_setting_new_value
        self.proposer_first_name = proposer_first_name
        self.proposer_last_name = proposer_last_name
        self.proposer_username = proposer_username
        self.proposer_id = proposer_id

def init_reform_table():
    try:
        import sqlite3
        import os
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS reforms (
        reform_id INTEGER PRIMARY KEY,
        reform_chat_id INTEGER,
        reform_name TEXT,
        reform_description TEXT,
        reform_date INTEGER,
        reform_implemented INTEGER,
        poll_id INTEGER,
        poll_is_boolean INTEGER,
        poll_max_voters_number INTEGER,
        poll_consensus_coefficient REAL,
        poll_active_time INTEGER,
        poll_yes_list TEXT,
        poll_no_list TEXT,
        change_ctype TEXT,
        change_mod_action TEXT,
        change_mod_modid TEXT,
        change_mod_workshopid TEXT,
        change_setting_variable TEXT,
        change_setting_old_value TEXT,
        change_setting_new_value TEXT,
        proposer_first_name TEXT,
        proposer_last_name TEXT,
        proposer_username TEXT,
        proposer_id INTEGER)''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Player:
    def __init__(self, steam_id, username, visit_count, last_seen, total_time, average_session, voted_yes, voted_no, proposed_change, got_change_accepted, got_change_rejected):
        self.steam_id = steam_id
        self.username = username
        self.visit_count = visit_count
        self.last_seen = last_seen
        self.total_time = total_time
        self.average_session = average_session
        self.voted_yes = voted_yes
        self.voted_no = voted_no
        self.proposed_change = proposed_change
        self.got_change_accepted = got_change_accepted
        self.got_change_rejected = got_change_rejected

def init_players_table():
    try:
        import sqlite3
        import os
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS players (
        steam_id INTEGER PRIMARY KEY,
        usernames TEXT,
        visit_count,
        last_seen,
        total_time,
        average_session,
        voted_yes,
        voted_no,
        proposed_change,
        got_change_accepted,
        got_change_rejected)''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        init_reform_table()
        init_players_table()
    except Exception as e:
        logger(e, "ERROR")

########################################
### QUERY FUNCTIONS
########################################

def get_player(steam_id):
    try:
        import sqlite3
        import os
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute('SELECT * FROM players WHERE steam_id = ?', (steam_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Player(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_reform(reform_id):
    try:
        import sqlite3
        import os
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE reform_id = ?', (reform_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_reform_by_poll_id(poll_id):
    try:
        import sqlite3
        import os
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE poll_id = ?', (poll_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def commit_reform_changes(reform_id):
    pass

def change_duplicate():
    pass

########################################################################################################################
### COMMAND SETUP & COMMAND RELATED
########################################################################################################################

### COMMANDS - FUNCTIONS

def add_cmd(command_list, cmd, description):
    from telebot import types
    #print("CMD: "+cmd+" ("+str(len(cmd))+")")
    #print("DESC: "+description+" ("+str(len(description))+")\n")
    command_list.append(types.BotCommand(command=str(cmd), description=str(description)))
    return True

def add_cmd_bulk(command_list, cmd_list):
    from telebot import types
    for cmd, description in cmd_list:
        add_cmd(command_list, cmd, description)
    return command_list

def init_commands():
    command_list = []
    return add_cmd_bulk(command_list, [[start_cmd,start_desc],[restart_cmd,restart_desc],[status_cmd,status_desc],[mod_cmd,mod_desc],[setting_cmd,setting_desc],[help_cmd,help_desc]])
    
### COMMAND - MESSAGES

start_cmd='start'
start_desc='Display bot welcome message.'
start_msg='Hi, I am Rotting Ghoul! I can automatically get you updates on the status of the PZserver.'
restart_cmd='restart'
restart_confirm_cmd='confirm_restart'
restart_cancel_cmd='cancel_restart'
restart_desc='Restart the application'
restart_msg="Are you really sure you want to restart the server? All users will be disconnected.\n\nPlease press: /"+restart_confirm_cmd+" to proceed.\n\nOr press: /"+restart_cancel_cmd+" to cancel."
status_cmd='status'
status_desc='Retrive the current status of '+SERVICE_NAME
mod_cmd='mod'
mod_desc='Allows to manage installed mods through vote'
mod_msg_helper='''
Please use:
        /'''+mod_cmd+''' list
        /'''+mod_cmd+''' install <Mod ID> <Workshop ID>
        /'''+mod_cmd+''' uninstall <Mod ID> OR <Workshop ID>'''
setting_cmd='setting'
setting_desc='Allows to manage server settings through vote'
setting_msg_helper='''
Please use:
        /'''+setting_cmd+''' get <any parameter>
        /'''+setting_cmd+''' set <any parameter>'''
help_cmd='help'
help_desc='Provide the command legenda.'
help_msg="List of the commands:\n/"+help_cmd+": "+help_desc+"\n/"+status_cmd+": "+status_desc+"\n/"+restart_cmd+": "+restart_desc+"\n/"+mod_cmd+": "+mod_msg_helper+"\n/"+setting_cmd+": "+setting_msg_helper

### OTHER MESSAGES

strip_modid_from_url_failed = "Getting modID from steam URL failed. Try using legacy syntax."
not_a_workshop_url = "The URL you provided has not been recognized as a valid workshop URL. Try the legacy syntax maybe?"

### COMMANDS - RESTART DOUBLE CHECK - no database, just memory

global_restart_requests = []

def save_restart(restart_cmd, user):
    global global_restart_requests
    for each in global_restart_requests:
        if each[1] == user:
            each[0] = cmd
            return
    global_restart_requests.append((cmd, user))        

def check_restart(restart_cmd, user):
    global global_restart_requests
    for each in global_restart_requests:
        if each[0] == cmd and each[1] == user:
            return True
    return False

def clear_restart(user):
    global global_restart_requests
    temp = global_restart_requests
    for each in global_restart_requests:
        if each[1] == user:
            temp.remove(each)
            removed = True
    global_restart_requests = temp
    print(global_restart_requests)
    if removed:
        return True
    else:
        return False

########################################################################################################################
### INITIALIZE BOT
########################################################################################################################

if __name__ == '__main__':
    try:
        import telebot
        bot = telebot.TeleBot(TOKEN)
        commands = init_commands()
        if commands:
            bot.set_my_commands(commands)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### BOT RELATED USEFUL TOOLS
########################################################################################################################

def send_to_all(text, silent=True):
    for each in ALL_CHATS:
        if silent:
            bot.send_message(each, text, disable_notification=True)
        else:
            bot.send_message(each, text)

def reply_to(message, text):
    pass

def member_is_admin(message):
    member = bot.get_chat_member(message.chat.id, message.from_user.id)
    if member.status in ['creator','administrator']:
        return True
    else:
        bot.reply_to(message, "This command requires administrator-level or superior priviledges.", disable_notification=True)
        return False

########################################################################################################################
### GAME RUNTIME LOG PARSING MANAGER
########################################################################################################################

### PARSING FLAGS & CONSTANTS

PZSERVER_LOG = '/opt/pzserver/pzserver.log'

command_flag = True
join_flag = True
left_flag = True

log_key_start = 'Zomboid Server is VAC Secure'
log_key_stop = 'command entered via server console (System.in): "quit"'
log_key_client_init=['[receive-packet] "client-connect"','steam-id','username']
log_key_client_connecting=['[receive-packet] "login-queue-request"','steam-id','username']
log_key_client_connected=['[receive-packet] "login-queue-done"','steam-id','username']
log_key_player_connected=['receive-packet] "player-connect"','steam-id','username']
log_key_player_in_game=['[fully-connected]','steam-id','username']
log_key_client_logout = ['[disconnect]','steam-id','username']
log_key_cmd = 'command entered'
log_key_death='replacing dead player'

### PARSING FUNCTIONS

def player_client_login_event(steamid, username):
    try:
        send_to_all("A player connected to the server: "+username)
    except Exception as e:
        logger(e, "ERROR")
        
def player_client_logout_event(steamid, username):
    try:
        send_to_all("A player left the server: "+username)
    except Exception as e:
        logger(e, "ERROR")

def alert_bot(keyword, line):
    try:
        import re
        if keyword == log_key_start:
            send_to_all(SERVICE_NAME.capitalize()+" is now online.")
            if not changes_are_applied():
                send_to_all("Seems like some changes were not applied since last reboot. Check logs for more info.")
        elif keyword == log_key_stop:
            send_to_all(SERVICE_NAME.capitalize()+" is going down...")
        elif command_flag and keyword == log_key_cmd:
            if '"quit"' not in line and '"save"' not in line:
                send_to_all("A"+line[44:])
        elif join_flag and keyword == log_key_client_init:
            match = re.search(r'username="([^"]*)" steam-id=(\d+)', log)
            if match:
                username = match.group(1)
                steamid = match.group(2)
                player_client_login_event(steamid, username)
        elif left_flag and keyword == log_key_client_logout:
            match = re.search(r'username="([^"]*)" steam-id=(\d+)', log)
            if match:
                username = match.group(1)
                steamid = match.group(2)
                player_client_logout_event(steamid, username)
    except Exception as e:
        logger(e, "ERROR")

def monitor_log(filename=PZSERVER_LOG, keywords=[log_key_start, log_key_stop, log_key_client_init, log_key_client_logout, log_key_cmd]):
    import time
    try:
        with open(filename, 'r') as f:
            f.seek(0, 2)
            while True:
                current_position = f.tell()
                line = f.readline()
                if not line:
                    time.sleep(0.1)
                    f.seek(current_position)
                else:
                    for keyword in keywords: 
                        if type(keyword)==str:
                            if keyword in line:
                                alert_bot(keyword, line)
                        elif type(keyword)==list:
                            if all(key_fragment in line for key_fragment in keyword):
                                alert_bot(keyword, line)
    except Exception as e:
        logger(e, "ERROR")

### START PARSING
if __name__ == '__main__':
    try:
        import threading
        poll_monitor_log_thread = threading.Thread(target=monitor_log)
        poll_monitor_log_thread.start()
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### POLLING MANAGER & MONITOR
########################################################################################################################

def create_poll(chat_id, description, options, anonymous=False, multiple_answers=False):
    poll = bot.send_poll(chat_id, question=description, options=options, is_anonymous=anonymous, allows_multiple_answers=multiple_answers)
    return poll

def stop_poll(reform):
    reform = get_reform_by_poll_id(poll_id)
    reform.poll_active_time = reform.reform_date - unix_timestamp()
    return bot.stop_poll(reform.chat_id, reform.poll_id)

def get_poll_max_voters_number(chat_id):
    return bot.get_chat_members_count(chat_id)

def consensus(poll_id, votes_from = 'db', max_voters_now = False, consensus = False, virdict = None):
    if votes_from == 'db':
        reform = get_reform_by_poll_id(poll_id)
    if max_voters_now:
        max_voters = bot.get_chat_members_count(reform.reform_chat_id)
    else:
        max_voters = reform.poll_max_voters_number
    if reform.poll_is_boolean:
        consensus_threshold = max_voters // 2 + 1 # Majority threshold
        if votes_from == 'db':
                yes_votes = len(reform.poll_yes_list.split(','))
                no_votes = len(reform.poll_no_list.split(','))
                if yes_votes >= consensus_threshold:
                    consensus, virdict = (True, True)
                    consensus_coefficient = yes_votes / consensus_threshold
                elif no_votes >= consensus_threshold:
                    consensus, virdict = (True, False)
                    consensus_coefficient = no_votes / consensus_threshold
        elif votes_from == 'tg':
            pass
    if consensus:
        stop_poll(poll_id)
        reform.poll_consensus_coefficient = consensus_coefficient
        commit_change(reform.reform_id)
        return (consensus, virdict)
    else:
        return (consensus, virdict)

def update_poll_vote(voter, poll_id, votes):
    try:
        reform = get_reform_by_poll_id(poll_id)
        if reform.poll_is_boolean:
            vote = votes[0]
            if vote == True:
                if reform.poll_yes_list:
                    reform.poll_yes_list = f"{reform.poll_yes_list}, {voter}"
                else:
                    yes_list = reform.poll_yes_list.split(',')
                    if voter not in yes_list:
                        yes_list.append(voter)
                        reform.poll_yes_list = f"{reform.poll_yes_list}, {voter}"
                        # WRITE TO REFORM DB
            elif vote == False:
                if reform.poll_no_list:
                    reform.poll_no_list = f"{reform.poll_no_list}, {voter}"
                else:
                    no_list = reform.poll_no_list.split(',')
                    if voter not in no_list:
                        no_list.append(voter)
                        reform.poll_no_list = f"{reform.poll_no_list}, {voter}"
                        # WRITE TO REFORM DB
            else: # retract_vote_option
                if reform.poll_yes_list:
                    yes_list = reform.poll_yes_list.split(',')
                    if voter in yes_list:
                        yes_list.pop(yes_list.index(voter))
                        removed_from_yes_list = True
                if reform.poll_no_list:
                    no_list = reform.poll_yes_list.split(',')
                    if voter in no_list:
                        no_list.pop(no_list.index(voter))
                        removed_from_no_list = True
                if removed_from_yes_list != removed_from_no_list:
                    return True
                if not reform.poll_yes_list and not reform.poll_no_listt:
                    logger("Vote is being retracted but vote lists are empty. What's happening?", "WARNING")
                if not removed_from_yes_list and not removed_from_no_list:
                    logger("Vote is being retracted but there was no vote to retract in DB. What's happening?", "WARNING")
                elif removed_from_yes_list and removed_from_no_list:
                    logger("Vote is being retracted from multiple list even if this was not a multi-answer poll. What's happening?", "WARNING")
                else:
                    logger("Vote is being retracted but I couldn't interpret this action correctly.", "WARNING")
    except Exception as e:
        logger(e, "ERROR")

def create_reform(message, ctype, change, legacy=False):
    try:
        if not change_duplicate():
            import sqlite3
            import os
            conn = sqlite3.connect(reforms_db)
            c = conn.cursor()
            new_reform = Reform()
            new_reform.reform_id = message.id
            new_reform.reform_chat_id = message.chat.id
            new_reform.reform_description = "" # FUTURE IMPLEMENTATION
            new_reform.reform_date = unix_timestamp()
            new_reform.poll_max_voters_number = get_poll_max_voters_number(message.chat.id)
            new_reform.proposer_first_name = message.from_user.first_name
            new_reform.proposer_last_name = message.from_user.last_name
            new_reform.proposer_username = message.from_user.username
            new_reform.proposer_id = message.from_user.id
            new_reform.change_ctype = ctype
            if ctype == 'mod':
                action, modid, workshopid = change
                new_reform.change_mod_action = action
                new_reform.change_mod_modid = modid
                new_reform.change_mod_workshopid = workshopid
                new_reform.reform_name = f"Do you want to {action} {modid}?"
                new_reform.poll_is_boolean = 1
                # FINALLY, LAUNCH THE POLL
                poll = create_poll(message.chat.id, new_reform.reform_name, ['Yes','No'])
                # GET THE PICTURE OF THE MOD FROM STEAM
                workshop_url = f"https://steamcommunity.com/sharedfiles/filedetails/?id={workshopid}"
                get_steam_image_url = strip_img_url_from_steam(workshop_url) 
                # AND SEND THE LINK WITH THE PICTURE
                bot.reply_to(poll, workshop_url, disable_notification=True)
                bot.send_photo(message.chat.id, get_steam_image_url)
            elif ctype == 'setting':
                variable, value = change
                new_reform.change_setting_variable = variable
                new_reform.change_setting_old_value = get_setting(variable).value
                new_reform.change_setting_new_value = value
                new_reform.reform_name = f"Set {variable} = {value}"
                new_reform.poll_is_boolean = 1
                # FINALLY, LAUNCH THE POLL
                poll = create_poll(message.chat.id, new_reform.reform_name, ['Yes','No'])
            new_reform.poll_id = poll.id
            # Construct the SQL query based on the attributes of the Reform object
            columns = ', '.join([col for col in new_reform.__dict__.keys()])
            placeholders = ', '.join(['?' for _ in range(len(new_reform.__dict__))])
            values = tuple(new_reform.__dict__.values())
            # Insert the values into the table
            c.execute(f'INSERT INTO reforms ({columns}) VALUES ({placeholders})', values)
            conn.commit()
            conn.close()
        else:
            reply_to(message, "This change has been already proposed and is under trial process.")
    except Exception as e:
        logger(e, "ERROR")

def commit_change(reform_id):
    reform = get_reform(reform_id)
    if reform.change_ctype == 'mod':
        if reform.change_mod_action == 'install':
            install_mod(modid, workshopid)
        elif reform.change_mod_action == 'uninstall':
            uninstall_mod(modid, workshopid)
        logger(f"Type: {reform.change_ctype} Action: {reform.change_mod_action} ModID: {reform.change_mod_modid} WorkshopID: {reform.change_mod_workshopid} Date: {log_timestamp}", "INFO")
    elif reform.change_ctype == 'setting':
        logger(f"Type: {reform.change_ctype} Variable: {reform.change_setting_variable} Old Value: {reform.change_setting_old_value} Current Value: {get_setting(change.variable).value} New Value: {reform.change_setting_new_value} Date: {log_timestamp}", "INFO")
        set_setting_value(reform.change_setting_variable, reform.change_setting_new_value)
    reform.reform_implemented = 1
    commit_reform_changes(reform_id)

########################################################################################################################
### MAIN - COMMAND HANDLERS
########################################################################################################################

if __name__ == '__main__':
    try:      
        # START
        @bot.message_handler(commands=[start_cmd])
        def send_start(message):
            bot.reply_to(message, start_msg, disable_notification=True)
        # HELP
        @bot.message_handler(commands=[help_cmd])
        def send_help(message):
            bot.reply_to(message, help_msg, disable_notification=True)
        # STATUS
        @bot.message_handler(commands=[status_cmd])
        def send_status(message):
            service_status = check_service_status()
            if service_status:
                status = "active."
            elif not service_status:
                status = "down."
            else:
                status = "???"
            bot.reply_to(message, "The PZserver is currently "+status)
        # RESTART
        @bot.message_handler(commands=[restart_cmd])
        def restart_server(message):
            is_admin = member_is_admin(message)
            if is_admin:
                if check_service_status():
                    save_restart(restart_cmd, message.from_user.id)
                    print(global_commands)
                    bot.reply_to(message, restart_msg, disable_notification=True)
                else:
                    bot.reply_to(message, "The server is currently down.", disable_notification=True)
        @bot.message_handler(commands=[restart_confirm_cmd])
        def confirm_restart(message):
            restart_required = check_restart(restart_cmd, message.from_user.id)
            if restart_required:
                clear_restart(message.from_user.id)
                run_command("sudo systemctl restart " + get_servicename())
        @bot.message_handler(commands=[restart_cancel_cmd])
        def cancel_restart(message):
            clear_restart(message.from_user.id)
        # MOD INSTALL / UNINSTALL
        @bot.message_handler(commands=[mod_cmd])
        def mod_command(message):
            command = message.text.split()
            if command[1] == 'list':
                if len(command) == 2:
                    modid_list, workshopid_list = get_mod_and_workshopid_list()
                    if not len(modid_list) and not len(workshopid_list):
                        bot.reply_to(message, "There are no mods installed.", disable_notification=True)
                    elif not len(modid_list) or not len(workshopid_list):
                        bot.reply_to(message, "It seems only two of the mod lists is empty. Corrupt?", disable_notification=True)
                        logger("It seems only two of the mod lists is empty. Corrupt?", "WARNING")
                    elif len(modid_list) == len(workshopid_list):
                        counter = 0
                        for modid in modid_list:
                            for workshopid in workshopid_list:
                                counter += 1
                                bot.reply_to(message, f"{counter}) {modid}\n\nhttps://steamcommunity.com/sharedfiles/filedetails/?id="+mod, disable_notification=True)
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            elif command[1] == 'install':
                if len(command) == 3:
                    if is_workshop_url(command[2]):
                        modid, workshopid = strip_IDs_from_steam(command[2])
                        create_reform(message, 'mod', ['install', modid, workshopid], legacy=False)
                    else:
                        bot.reply_to(message, not_a_workshop_url, disable_notification=True)
                        bot.reply_to(message, mod_msg_helper, disable_notification=True)
                elif len(command) == 4:
                    installed = mod_is_installed(command[2], command[3])
                    modid, workshopid = is_modid_workshopid(command[2], command[3])
                    if installed:
                        bot.reply_to(message, "The mod you want to install is already installed. Is there a issue related to mod loading perhaps?", disable_notification=True)
                    else:
                        create_reform(message, 'mod', ['install', modid, workshopid], legacy=True)
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            elif command[1] == 'uninstall':
                if len(command) == 3:
                    if is_workshop_url(command[2]):
                        modid, workshopid = strip_IDs_from_steam(command[2])
                        create_reform(message, 'mod', ['uninstall', modid, workshopid], legacy=False)
                    elif mod_is_installed(command[2]):
                        modid, workshopid = mod_is_installed(command[2])
                        create_reform(message, 'mod', ['uninstall', modid, workshopid])
                    else:
                        bot.reply_to(message, mod_msg_helper, disable_notification=True)
                elif len(command) == 4:
                    installed = mod_is_installed(command[2], command[3])
                    if installed:
                        modid, workshopid = installed
                        create_reform(message, 'mod', ['uninstall', modid, workshopid])
                else:
                    bot.reply_to(message, mod_msg_helper, disable_notification=True)
            else:
                bot.reply_to(message, mod_msg_helper, disable_notification=True)
        # MODIFY PZSERVER SETTINGS
        @bot.message_handler(commands=[setting_cmd])
        def setting_command(message):
            command = message.text.split()
            if command[1] == "get":
                if len(command) == 3:
                    if is_setting(command[2]):
                        bot.reply_to(message, get_setting(command[2]).value, disable_notification=True)
                        bot.reply_to(message, get_setting(command[2]).description, disable_notification=True)
                    else:
                        bot.reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?", disable_notification=True)
                else:
                    bot.reply_to(message, setting_msg_helper, disable_notification=True)
            elif command[1] == "set":
                if len(command) == 4:
                    if is_setting(command[2]):
                        create_reform(f"{message.from_user.first_name} {message.from_user.last_name}", message.from_user.id, message.chat.id, message.id, 'setting', [command[2], command[3]])
                    else:
                        bot.reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?", disable_notification=True)
                else:
                    bot.reply_to(message, setting_msg_helper, disable_notification=True)
            else:
                bot.reply_to(message, setting_msg_helper, disable_notification=True)
        # LISTEN FOR UPDATES FROM YOUR NON-ANONYMOUS POLLS
        @bot.poll_answer_handler()
        def poll_vote_event(update):
            update_poll_vote(update.user.id, update.poll_id, update.option_ids)

        ########################################
        ### TELEBOT - START POLLING
        ########################################
        
        log_emendazio()
        bot.infinity_polling()
        
    except Exception as e:
        logger(e, "ERROR")
