#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    @@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  ,@@@@@@@@@@@@@@@@@@@@@  @@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@%        @@       @@      @@   /@@&     .@@@     #%    /@@@@  .      @@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@%  /@@  .@&  #@@@@  ,@@,  @&  /@@  .@@  /@.  @@@@@@  *@@@@@, @@      @@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  /@@  ,@@  #@@@%  *@@   @@  (@&  ,@@@@@@  .@@@@@@  *@@@@@  @.    ,&*@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  ,@@  #@@  #@@@@, .@@  #@@  (@@*  @@@(/@(  @@@ /@  *@@@@@@%   (. .@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@.  /@@@@@@@@@@@@@@@@@@@@@#@%  %@@@@@@@@@@@@@@@@@@@@@@@@@@@@,  .@@%  @@@@@@@@@@@@@@@@@@@@@@@@@
#@                 @@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@&&&@@@@@@@@@@@@@@@@@@   (@@@  (@@@@@@@@@@@@@@@@@@@@@@@@@
#                  /@@%     .%@@@@@@@@@@@@@@@@@@@@@@@@@@@*            .@@@@@@@@@@       (@@@(  #@@@@           ,/@@@@@@@@
#      &@@@@@     *@@     .    &@       .@@@@@@@@        @#    /@@@.    &@@@@@          .@@@@.      @%     .*.     %@@@@@
#     &@@@@@      @@,   &@@&    @@       /@@@@@@       ,@@%    %@@@@     #@@,     @@@/    #@@@    .@@@     @@@@*    @@@@@
#    &@@@@@      (@@   .@@@@    /@(      ,@@@@@/       (@@*    (@@@@(    ,@@.    @@@@@     %@@    &@@@     @@@@@     &@@@
#   *@@@@@#      @@.   %@@@@    .@(       &@@@@        #@@@    /@@@@.    %@@     @@@@@*    (@@    @@@#     @@@@@#    .@@@
#/ @@@@@@@      @@@    &@@@@     @#       .@@@@        /@@#    (@@@.     @@*     @@@@@     ,@@    %@@@     @@@@@@     @@@
#@@@@@@@@      &@@@    %@@@@     @#        #@@#        ,@@#    ,@@(     @@@     /@@@@@.     @@    #@@@     &@@@@&     @@@
#@@@@@@@      #@@@,    #@@@@     &#        *@@*        .@@@           (@@@@     %@@@@@*     %@    *@@@     (@@@@      %@@
#@@@@@@&     *@@@@,    (@@@@/    @#   .     @%          @@#    (@@@     %@@     &@@@@@@     ,@.   /@@&     /@@@@      /@@
#@@@@@@      %@@@@,    /@@@@    ,@#   %@.        @#    .@@*    %@@@@,    #@     #@@@@@@     %@.   #@@@     (@@@@      ,@@
#@@@@@      *@@@@@@,   /@@@@    (@(   @@/       (@,    ,@@*    #@@@@/    ,@,    /@@@@@      @@    %@@@     @@@@@@     (@@
#@@@@      .@@@@@@@@   .@@@%    /@(   @@@       @@     *@@*    %@@@@     ,@*    ,@@@@@     ,@@    %@@@     @@@@@#     @@@
#@@@@      @@@@@@@( (    #/   .@@@,   (@@.     .@@.    (@@,    &@@@@     (@(    .@@@@@     #@@.   /@@@     @@@@@     #@@@
#@@@      %@@@@@@   /@@.    (@@@@@    .@@@     ,@@(    &@@,    %@@@      @@@    .@@@@@     &@&    .@@&.    @@@@@     @@@@
#@@      /@@@@@@    @@@@@@@@@@@@@@/   .@@@,    %@@     /@             (@@@@@@.   (@@@.     @@.     /@@    ,@@@@     @@@@@
#@      ,@@@@@@     @@@@@@@@@@@@@@    /@@@&   ,@@@     ,@@@@@@@@@@&@@@@@@@@@@@    ,@/    /@@@@@@@@@@@.      /     *@@@@@@
#@      @@@@@@      @@@@@@@@@@@@@      &@@@   @@@(      %@###%.,/###%@((    #@@@,      *@@@@@@@@@@@@@/ ,((,..*/%@@@@@@@@@
#                   &@@@@@@@@@@@@(,(#(*@@@@@@@@@@( ,//*,&@@                     /@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##(*,,. ..,,*****,*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&##                         .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         .%*/@@@( (%#/          /#&( &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     .#(   / .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Please install pip on your system, install the dependencies that will be throwing errors when you launch the program and create a separate python virtual environmment (very easy to do) to launch this software.
# Oh, also remember to get a telegram bot TOKEN from the botfather bot and replace the TOKEN variable value with it. You will need to put the group chat id in SERVER_CHATS. To get your group chat id, add the bot to the group chat and use the command /id
# Also make sure your bot is in your public group with admin priviledges and disable the privacy setting of your bot from botfather chat using /setprivacy command or whatever it is.
# I think this should be it...

# PZserver TG Module - Copyright (C) 2023 Damiano Meda
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail.
# If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:

# PZserver TG Module - Copyright (C) 2023 Damiano Meda
# This program comes with ABSOLUTELY NO WARRANTY; This is free software, and you are welcome to redistribute it under certain conditions. Contact me at damiano.meda@gmail.com if you want to do so.

########################################
### FUNDAMENTAL CONSTANTS
########################################

import os
import sys
import platform

if __name__ == '__main__':
    if '--debug' in sys.argv:
        DEBUG_MODE = 1
    else:
        DEBUG_MODE = 0

if __name__ == '__main__':
    # USEFUL PATHS OF RECURRENT USAGE
    FILENAME = os.path.basename(__file__)
    BASENAME = os.path.splitext(FILENAME)[0]
    THIS_FOLDER = os.path.abspath(os.path.dirname(__file__))
    THIS_LOG_FILE = os.path.join(THIS_FOLDER, BASENAME+'.log')
    SERVICE_FOLDER = os.path.abspath(os.path.join(THIS_FOLDER, os.pardir))
    SERVICE_NAME = os.path.basename(SERVICE_FOLDER) # Please put the server in a folder with a name different form "vanilla" or "default"
    SERVICE_LOG = os.path.join(THIS_FOLDER, SERVICE_NAME+'.log')
    SERVICE_MANAGER = os.path.join(SERVICE_FOLDER, SERVICE_NAME+"_manager.sh")
    HOME_FOLDER = os.path.expanduser("~")
    ZOMBOID_FOLDER=os.path.join(HOME_FOLDER, 'Zomboid')
    ZOMBOID_SETTINGS_FOLDER=os.path.join(ZOMBOID_FOLDER, 'Server')
    ZOMBOID_PLAYER_DB=os.path.join(ZOMBOID_FOLDER, 'Saves/Multiplayer/'+SERVICE_NAME+'/players.db')
    ZOMBOID_SERVER_DB=os.path.join(ZOMBOID_FOLDER, 'db/'+SERVICE_NAME+'.db')

    # THIS WILL SLOW DOWN BOOT PROCESS A BIT
    AUTOUPDATE_VANILLA_SETTINGS_ON_START = 2 # 1=Always, 0=Never, 2=Only On Mod Changes
    VANILLA_SERVER_NAME = "vanilla"
    VANILLA_LOG_FILE = os.path.join(SERVICE_FOLDER, VANILLA_SERVER_NAME+".log")

    # CURRENT SETTINGS
    SERVERINI_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, SERVICE_NAME+".ini")
    SANDBOXVARS_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, SERVICE_NAME+"_SandboxVars.lua")
    # VANILLA SETTINGS
    VANILLA_SERVERINI_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, VANILLA_SERVER_NAME+".ini")
    VANILLA_SANDBOXVARS_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, VANILLA_SERVER_NAME+"_SandboxVars.lua")
    # USER_DEFINED STANDARD SETTINGS
    DEFAULT_SERVERINI_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, "default.ini")
    DEFAULT_SANDBOXVARS_PATH = os.path.join(ZOMBOID_SETTINGS_FOLDER, "default_SandboxVars.lua")
    
    # TELEGRAM STUFF
    SERVER_CHATS=[-1002033569385] #Production
    DEBUG_CHAT = [-4167198763] #Test
    TOKEN = '6353909839:AAEQRzoSX9pXCL0sCtRUiw0aWW4via9bgzU' # Telegram Bot API TOKEN
    DEVS=[45386832] #Your telegram ID. It will allow you to force changes.

########################################################################################################################
### INFORMATION FOR THE LOG FILE
########################################################################################################################

def log_timestamp():
    from datetime import datetime
    return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

def logger(message, msg_type, log_file=THIS_LOG_FILE):
    import os
    import traceback
    with open(log_file, 'a') as f:
        timestamp = log_timestamp()
        msg_body = f"[{timestamp}][{msg_type}] {str(message)}"
        if DEBUG_MODE:
            print(msg_body)
        f.write(msg_body+"\n")
        traceback_str = traceback.format_exc()
        if msg_type == 'ERROR':
            if traceback_str:
                msg_body = f"[{timestamp}][TRACEBACK] {traceback_str}"
                if DEBUG_MODE:
                    print(msg_body)
                f.write(msg_body+"\n")

def log_emendazio(max_rows=1000, buffer=300, log_file=THIS_LOG_FILE):
    try:
        with open(log_file, 'r') as f:
                lines = f.readlines()
                if len(lines) >= max_rows:
                    lines = lines[-(max_rows - buffer):]
                with open(log_file, 'w') as f:
                    f.writelines(lines)
    except Exception as e:
        logger(e, "ERROR")
        return None

########################################################################################################################
### USEFUL TOOLS
########################################################################################################################

def string_is_integer(s):
    try:
        int(s)
        return True
    except Exception as e:
        logger(e, "ERROR")

def timestamp():
    try:
        from datetime import datetime
        return datetime.now()
    except Exception as e:
        logger(e, "ERROR")

def unix_timestamp():
    try:
        import time
        return int(time.time())
    except Exception as e:
        logger(e, "ERROR")

def unix_timestamp_to_log_timestamp(unix_timestamp):
    try:
        from datetime import datetime
        return datetime.utcfromtimestamp(unix_timestamp).strftime('%Y-%m-%d %H:%M:%S')
    except Exception as e:
        logger(e, "ERROR")

def log_timestamp_to_unix_timestamp(log_timestamp):
    try:
        from datetime import datetime
        return int(datetime.strptime(log_timestamp, '%Y-%m-%d %H:%M:%S').timestamp())
    except Exception as e:
        logger(e, "ERROR")

def run_command(command, log=True):
    try:
        if DEBUG_MODE:
            if log:
                logger(f"#!/bin/bash: {command}", "DEBUG")
        import subprocess
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output, error = process.communicate()
        if process.returncode != 0:
            if output:
                logger(output, "OS ERROR")
            if error:
                logger(error, "OS ERROR")
            return False
        return output
    except Exception as e:
        logger(e, "ERROR")

def rm(path):
    try:
        if os.path.exists(path):
            return run_command("rm "+path)
    except Exception as e:
        logger(e, "ERROR")

def check_service_status(service_name=SERVICE_NAME):
    try:
        import subprocess
        if 'Active: active (running)' in run_command('systemctl status '+SERVICE_NAME).split('\n')[2]:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")
        return None

def strip_img_url_from_steam(workshop_url):
    try:
        img_url = run_command("curl -kl "+workshop_url+" | grep \"steamuserimages-a.akamaihd.net/ugc\" | egrep -v \"property|twitter\" | grep \"letterbox=true\" | head -1 | awk \'{print $2}\'").split("?")[0][1:]
        logger(f"A image url has been stripped from steam workshop: {img_url}", "INFO")
        return img_url
    except Exception as e:
        logger(e, "ERROR")

def is_workshop_url(url):
    try:
        import re
        pattern = r"https:\/\/steamcommunity\.com\/sharedfiles\/filedetails\/\?id=\d+"
        if re.match(pattern, url):
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def valid_steam_id(steam_id):
    try:
        if steam_id.isdigit() and len(steam_id) == 17:
            return int(steam_id)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def ensure_max_occurrences(array, value, N):
    try:
        count = 0
        index = 0
        while index < len(array):
            if array[index] == value:
                count += 1
                if count > N:
                    del array[index]
                    continue  # Continue without incrementing index
            index += 1
        return array
    except Exception as e:
        logger(e, "ERROR")

def format_time(seconds, precision='s'):
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        if precision == 's':
            return f"{int(hours)} h {int(minutes)} m {int(seconds)} s"
        elif precision == 'm':
            return f"{int(hours)} h {int(minutes)} m"
        else:
            return f"{int(hours)} h"
    elif minutes > 0:
        if precision == 's':
            return f"{int(minutes)} m {int(seconds)} s"
        else:
            return f"{int(minutes)} m"
    else:
        return f"{int(seconds)} s"

def fake_message(chat_id, message_id):
    try:
        class fakemessage:
            def __init__(self, chat_id, message_id):
                self.chat_id = chat_id
                self.message_id = message_id
            @property
            def chat(self):
                return fakechat(self.chat_id)
            @property
            def id(self):
                return self.message_id
        class fakechat:
            def __init__(self, chat_id):
                self.chat_id = chat_id
            @property
            def id(self):
                return self.chat_id
        # Eat your broccoli, bitch
        return fakemessage(chat_id, message_id)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### AVOID DOUBLE EXECUTION OF THIS SCRIPT ON THE CURRENT SYSTEM
########################################################################################################################

def get_pid_and_name():
    import os
    import sys
    try:
        return (os.getpid(), os.path.abspath(sys.argv[0]))
    except Exception as e:
        logger(e, "ERROR")

def is_already_running(current_pid, current_script):
    try:
        processes = run_command('ps aux | grep ' + current_script)
        if processes:
            lines = processes.split('\n')
            for line in lines:
                if current_script in line and 'python' in line:
                    pid = int(line.split()[1])
                    if pid != current_pid:
                        return True, pid
        return False, None
    except Exception as e:
        logger(e, "ERROR")

def stop_previous_instance(pid):
    try:
        import os
        import signal
        print(f"Stopping previous instance with PID: {pid}")
        os.kill(pid, signal.SIGTERM)
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        import sys
        pid, name = get_pid_and_name()
        restart_flag = '--restart' in sys.argv
        already_running, running_pid = is_already_running(pid, name)
        if already_running:
            if restart_flag:
                if running_pid:
                    stop_previous_instance(running_pid)
                else:
                    print("Couldn't determine the PID of the previous instance.")
                    sys.exit(1)
            else:
                print("Another instance of the script is already running.")
                sys.exit(1)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### INITIALIZE BOT
########################################################################################################################

if __name__ == '__main__':
    try:
        import telebot
        bot = telebot.TeleBot(TOKEN)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### BOT RELATED USEFUL TOOLS
########################################################################################################################

def cheat_alert(text, disable_notification=True, disable_web_page_preview=False, parse_mode='Markdown'):
    try:
        for each in SERVER_CHATS:
            bot.send_message(each, text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview, parse_mode=parse_mode)
    except Exception as e:
        logger(e, "ERROR")

def server_chat_message(text, disable_notification=True, disable_web_page_preview=False, parse_mode='Markdown'):
    try:
        if not DEBUG_MODE:
            for each in SERVER_CHATS:
                bot.send_message(each, text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview, parse_mode=parse_mode)
        else:
            bot.send_message(DEBUG_CHAT[0], text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview, parse_mode=parse_mode)
    except Exception as e:
        logger(e, "ERROR")

def reply_to(message, text, disable_notification=True, disable_web_page_preview=False, parse_mode='Markdown'):
    try:
        bot.reply_to(message, text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview, parse_mode=parse_mode)
    except Exception as e:
        logger(e, "ERROR")

def member_is_admin(message):
    try:
        member = bot.get_chat_member(message.chat.id, message.from_user.id)
        if member.status in ['creator','administrator']:
            return True
        else:
            reply_to(message, "This command requires administrator-level or superior priviledges.", disable_notification=True)
            return False
    except Exception as e:
        logger(e, "ERROR")

def member_is_dev(message):
    try:
        if message.from_user.id in DEVS:
            return True
        else:
            reply_to(message, msg_only_master)
            return False
    except Exception as e:
        logger(e, "ERROR")

def split_msg_in_chunks(text, telegram_msg_max_lenght=4096):
    try:
        chunks = []
        current_text = ""
        if text:
            if isinstance(text, str):
                for line in text.splitlines():
                    if len(current_text) + len(line) > telegram_msg_max_lenght:
                        chunks.append(current_text)
                        current_text = ""
                    current_text += line+"\n"
                if current_text:
                    chunks.append(current_text)
                return chunks
            else:
                return ["(ಠ ∩ಠ)"]
        else:
            return ["(ಠ ∩ಠ)"]
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### SERVER SETTINGS
########################################################################################################################

def process_serverini(line):
    try:
        if line.startswith("#"):
            return (1, line.strip()[2:])
        elif "=" in line:
            line = line.split("=")
            variable, value = line[0].strip(), line[1].strip()
            return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def process_sandbox_vars(line):
    try:
        if "=" in line:
            if "{" in line:
                return None
            elif "--" in line:
                return (1, line.strip()[3:])
            else:
                line = line.split("=")
                variable, value = line[0].strip(), line[1].strip()[:-1]
                return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    #.ini
    SERVERINI = [SERVERINI_PATH, process_serverini]
    VANILLA_SERVERINI = [VANILLA_SERVERINI_PATH, process_serverini]
    DEFAULT_SERVERINI = [DEFAULT_SERVERINI_PATH, process_serverini]
    #_SandboxVars.lua
    SANDBOXVARS = [SANDBOXVARS_PATH, process_sandbox_vars]
    VANILLA_SANDBOXVARS = [VANILLA_SANDBOXVARS_PATH, process_sandbox_vars]
    DEFAULT_SANDBOXVARS = [DEFAULT_SANDBOXVARS_PATH, process_sandbox_vars]

def get_settings(serverini, sandboxvars):
    try:
        import os
        if os.path.exists(serverini[0]) and os.path.exists(sandboxvars[0]):
            setting_files = [serverini, sandboxvars]
            class Variable:
                def __init__(self, value, description, file_path, line_number, basename):
                    self.value = value
                    self.description = description
                    self.path = file_path
                    self.line = line_number
                    self.basename = basename
            class Settings:
                def print_all(self):
                    for attr, value in vars(self).items():
                        if isinstance(value, Variable):
                            print(f"{attr}: {value.value}")
            settings = Settings()
            for file_path, processor in setting_files:
                basename = os.path.basename(file_path)
                with open(file_path, 'r') as file:
                    description = ""
                    line_number=0
                    for line in file:
                        processed = processor(line)
                        if processed:
                            is_description, data = processed[0], processed[1]
                            if is_description:
                                description += data + "\n"
                            else:
                                variable, value = data
                                setattr(settings, variable, Variable(value, description, file_path, line_number, basename))
                                #print("section: "+basename); print(variable+": "+value); print(description); print(line_number); print("-------------------------")
                                description = ""
                        line_number += 1
            return settings
        logger(f"\'{serverini[0]}\' or \'{sandboxvars[0]}\' wasn't found.", "ERROR")
        return None
    except Exception as e:
        logger(e, "ERROR")

def compare_settings(settings_to_show, settings_as_reference, as_text=False, console=False, exclusion_list=[], exclude_AntiCheatProtectionType=True):
    try:
        differences = []
        missing_in_subject = []
        missing_in_reference = []
        show_attributes = vars(settings_to_show).items()
        for var_name, show_var_content in show_attributes:
            if hasattr(settings_as_reference, var_name):
                ref_var_content = getattr(settings_as_reference, var_name)
                if show_var_content.value != ref_var_content.value and var_name not in exclusion_list:
                    if exclude_AntiCheatProtectionType:
                        if not var_name.startswith("AntiCheatProtectionType"):
                            # Differences between same settings
                            differences.append((var_name, show_var_content, ref_var_content))
                    else:
                        # Differences between same settings
                        differences.append((var_name, show_var_content, ref_var_content))
            else:
                # Probably empty
                missing_in_subject.append((var_name, show_var_content.value))
        reference_attributes = vars(settings_as_reference).items()
        for var_name, ref_var_content in reference_attributes:
            if not hasattr(settings_to_show, var_name):
                # If you want to collect also settings related to mods
                missing_in_reference.append((var_name, ref_var_content.value))
        if as_text:
            text_differences = ""
            for var_name, show_var_content, ref_var_content in differences:
                if not console:
                    line = f"<b>{var_name}</b>: {show_var_content.value} | {ref_var_content.value}\n"
                else:
                    line = f"[{show_var_content.basename}] {var_name}: {show_var_content.value} [{ref_var_content.basename}: {ref_var_content.value}]\n"
                text_differences += line
            return split_msg_in_chunks(text_differences)
        else:
            return [differences,missing_in_subject,missing_in_reference]
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    global_settings = get_settings(SERVERINI, SANDBOXVARS)
    if not global_settings:
        print("File settings were not found. Being an almost essential part, I'll exit.")
        exit()

########################################
### SETTINGS MANAGERS
########################################

def reload_settings():
    try:
        global global_settings
        global_settings = get_settings(SERVERINI, SANDBOXVARS)
    except Exception as e:
        logger(e, "ERROR")

def setting_timestamp():
    try:
        pass
    except Exception as e:
        logger(e, "ERROR")

def save_setting_to_file(setting, value, source_settings=global_settings):
    try:
        file_path = getattr(source_settings, setting).path
        with open(file_path, 'r') as file:
            all_lines = file.readlines()
            line_number = getattr(source_settings, setting).line
            line = all_lines[line_number]
            if setting in line:
                old_setting = getattr(source_settings, setting)
                if old_setting.value != "":
                    new_line = line.replace(old_setting.value, value)
                else:
                    if ".ini" in old_setting.basename:
                        line = line.split("=")
                        line.insert(1, "="+value)
                        new_line = ''.join(line)
                    elif ".lua" in old_setting.basename:
                        line = line.split("=")
                        line.insert(1, "= "+value)
                        new_line = ''.join(line)
                    else:
                        logger(f"Not determinable file type for: {old_setting.basename}", "ERROR")
                logger(f"In: {file_path}\n{new_line}", "CHANGE")
                all_lines[line_number] = new_line
                with open(file_path, 'w') as file:
                    file.writelines(all_lines)
                return True
            return False
    except Exception as e:
        logger(e, "ERROR")

def is_setting(setting):
    try:
        return hasattr(global_settings, setting)
    except Exception as e:
        logger(e, "ERROR")

def get_setting(setting, source_settings=global_settings):
    try:
        if hasattr(source_settings, setting):
            return getattr(source_settings, setting)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def set_setting_value(setting, value, source_settings=global_settings):
    try:
        if hasattr(source_settings, setting):
            if save_setting_to_file(setting, value, source_settings=source_settings):
                reload_settings()
                return True
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################
### MOD MANAGER & TOOLS
########################################

def is_modid(mod_id):
    try:
        return (char.isalnum() or char == '_' for char in mod_id)
    except Exception as e:
        logger(e, "ERROR")

def is_workshopid(workshop_id):
    try:
        return all(char.isdigit() for char in workshop_id) and len(workshop_id) == 10
    except Exception as e:
        logger(e, "ERROR")

def sort_valid_modid_workshopid(id1, id2):
    try:
        if is_workshopid(id1):
            if is_modid(id2):
                return[id2,id1]
            else:
                return False
        elif is_workshopid(id2):
            if is_modid(id1):
                return[id1,id2]
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def valid_modid_list(modid_list):
    try:
        if not modid_list:
            return True  # Empty string is allowed
        return all(is_modid(item) for item in modid_list)
    except Exception as e:
        logger(e, "ERROR")

def valid_workshopid_list(workshopid_list):
    try:
        if not workshopid_list:
            return True  # Empty string is allowed
        return all(is_workshopid(item) for item in workshopid_list)
    except Exception as e:
        logger(e, "ERROR")

def valid_modid_workshopid_list(modid_list, workshopid_list):
    try:
        return len(modid_list) == len(workshopid_list) and valid_modid_list(modid_list) and valid_workshopid_list(workshopid_list)
    except Exception as e:
        logger(e, "ERROR")

def get_mod_and_workshopid_list():
    try:
        modid_list = get_setting('Mods').value
        workshopid_list = get_setting('WorkshopItems').value
        if modid_list and workshopid_list:
            return ((modid_list.split(';'), workshopid_list.split(';')))
        else:
            return (([],[])) # No mods installed
    except Exception as e:
        logger(e, "ERROR")

def get_valid_modid_workshopid_list():
    try:
        modid_list, workshopid_list = get_mod_and_workshopid_list()
        if valid_modid_workshopid_list(modid_list, workshopid_list):
            return (modid_list, workshopid_list)
        else:
            logger("Sanity check failing for mod lists.", "WARNING")
            return False
    except Exception as e:
        logger(e, "ERROR")

def get_workshopid_from_installed_mods(modid):
    try:
        valid_mod_lists = get_valid_modid_workshopid_list()
        if valid_mod_lists:
            modid_list, workshopid_list = valid_mod_lists
            if is_modid(modid):
                if modid in modid_list:
                    return workshopid_list[modid_list.index(modid)]
                else:
                    return False
            else:
                return None
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None

def strip_IDs_from_steam(url):
    try:
        import requests
        import re
        response = requests.get(url)
        if response.status_code == 200:
            source_code = response.text
            match = re.search(r"Mod ID:\s*([a-zA-Z0-9_()]+)", source_code)
            if match:
                mod_id = match.group(1)
                return sort_valid_modid_workshopid(mod_id, url.split('=')[1])
            return False
        else:
            logger(f"Failed to fetch page. Status code: {str(response.status_code)}", "ERROR")
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None
            
def mod_is_installed(id1, id2):
    try:
        valid = sort_valid_modid_workshopid(id1, id2)
        if valid:
            modid, workshopid = valid
            valid = get_valid_modid_workshopid_list()
            if valid:
                mod_list, workshop_list = valid
                if modid not in mod_list and workshopid not in workshop_list:
                    return False
                elif modid in mod_list:
                    if workshopid in workshop_list:
                        if mod_list.index(modid) == workshop_list.index(workshopid):
                            return True
                        else:
                            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted installed but are not at the same position in config file. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING") #This case might be a hint for issues in loading mods in game
                            return None
                    elif workshopid not in workshop_list:
                        logger(f"{modid} is in the list but {workshopid} isn't. Weird, since a workshopid can have multiple modid but not viceversa. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING") #This case might be a hint for issues in loading mods in game
                        return None
                else:
                    logger(f"{modid} is not in the list but {workshopid} is. It could be a portion of the same mod with a different name.", "INFO", THIS_LOG_FILE) #This case might be a hint for issues in loading mods in game
                    return False
            else:
                return valid
        else:
            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") are invalid. Are you having fun or what?", "WARNING", THIS_LOG_FILE)
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None

def install_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modids=get_setting(modid_setting).value
        workshopids=get_setting(workshopid_setting).value
        set_setting_value(modid_setting, modids+";"+modid)
        set_setting_value(workshopid_setting, workshopids+";"+workshopid)
    except Exception as e:
        logger(e, "ERROR")

def uninstall_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modid_list, workshopid_list = get_valid_modid_workshopid_list()
        position = modid_list.index(modid)
        modid_list.pop(position)
        workshopid_list.pop(position)
        modid_list_text = ';'.join(map(str, modid_list))
        workshopid_list_text = ';'.join(map(str, workshopid_list))
        set_setting_value('Mods', modid_list_text)
        set_setting_value('WorkshopItems', workshopid_list_text)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### DATABASES PLAYGROUND
########################################################################################################################

if __name__ == '__main__':
    import os
    pztgdb = os.path.join(THIS_FOLDER, 'pztg.db')

# TO CREATE SETTINGS BACKUPS
def selfcreate_sqlite_table(table_name, **kwargs):
    import sqlite3
    import os
    try:
        if len(kwargs) < 1:
            return
        db_file = f"{table_name}.db"
        db_path = os.path.join(THIS_FOLDER, db_file)
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        pk = list(kwargs.keys())[0]
        columns = []
        for key, value in kwargs.items():
            valid_types = [int, float, str]
            if type(value) not in valid_types:
                return False
            sqlite_type = {int: "INTEGER", float: "REAL", str: "TEXT"}[type(value)]
            if key == pk:
                columns.append(f"{key} {sqlite_type} PRIMARY KEY")
            else:
                columns.append(f"{key} {sqlite_type}")
        if len(columns) < 1:
            return False
        create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
        c.execute(create_table_sql)
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Reform:
    def __init__(self, reform_id=None, reform_chat_id=None, reform_name=None, reform_description=None, reform_date=None, reform_implemented=None, reform_is_active = None,
                poll_id=None, poll_message_id=None, poll_options=None,poll_consensus_coefficient=None, poll_stop_date=None, poll_yes_list="", poll_no_list="",
                change_ctype=None, change_mod_action=None, change_mod_modid=None, change_mod_workshopid=None, change_setting_variable=None, change_setting_old_value=None, change_setting_new_value=None,
                proposer_first_name=None, proposer_last_name=None, proposer_username=None, proposer_id=None):
        self.reform_id = reform_id
        self.reform_chat_id = reform_chat_id
        self.reform_name = reform_name
        self.reform_description = reform_description
        self.reform_date = reform_date
        self.reform_implemented = reform_implemented
        self.reform_is_active = reform_is_active
        self.poll_id = poll_id
        self.poll_message_id = poll_message_id
        self.poll_options = poll_options
        self.poll_consensus_coefficient = poll_consensus_coefficient
        self.poll_stop_date = poll_stop_date
        self.poll_yes_list = poll_yes_list
        self.poll_no_list = poll_no_list
        self.change_ctype = change_ctype
        self.change_mod_action = change_mod_action
        self.change_mod_modid = change_mod_modid
        self.change_mod_workshopid = change_mod_workshopid
        self.change_setting_variable = change_setting_variable
        self.change_setting_old_value = change_setting_old_value
        self.change_setting_new_value = change_setting_new_value
        self.proposer_first_name = proposer_first_name
        self.proposer_last_name = proposer_last_name
        self.proposer_username = proposer_username
        self.proposer_id = proposer_id
    
    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_reform_table():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS reforms
            (
                reform_id INTEGER PRIMARY KEY,
                reform_chat_id INTEGER,
                reform_name TEXT,
                reform_description TEXT,
                reform_date INTEGER,
                reform_implemented INTEGER,
                reform_is_active INTEGER,
                poll_id INTEGER,
                poll_message_id INTEGER,
                poll_options INTEGER,
                poll_consensus_coefficient REAL,
                poll_stop_date INTEGER,
                poll_yes_list TEXT,
                poll_no_list TEXT,
                change_ctype TEXT,
                change_mod_action TEXT,
                change_mod_modid TEXT,
                change_mod_workshopid TEXT,
                change_setting_variable TEXT,
                change_setting_old_value TEXT,
                change_setting_new_value TEXT,
                proposer_first_name TEXT,
                proposer_last_name TEXT,
                proposer_username TEXT,
                proposer_id INTEGER
            )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Player:
    def __init__(self, ID, username, banned, accesslevel, firstconnection, lastconnection, steam_id, telegram_id):
        self.ID = ID
        self.username = username
        self.banned = banned
        self.accesslevel = accesslevel
        self.firstconnection = firstconnection
        self.lastconnection = lastconnection
        self.steam_id = steam_id
        self.telegram_id = telegram_id
    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_players_table():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS players
            (
                id INTEGER PRIMARY KEY,
                username TEXT,
                banned INTEGER,
                accesslevel TEXT,
                firstconnection TEXT,
                lastconnection TEXT,
                steam_id INTEGER,
                telegram_id INTEGER
            )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Session:
    def __init__(self, session_id=None, steam_id=None):
        self.session_id = session_id
        self.steam_id = steam_id

    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_sessions_table():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS sessions
            (
                session_id INTEGER PRIMARY KEY,
                steam_id INTEGER,
                login INTEGER,
                logout INTEGER,
                ip TEXT
            )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def init_mfa_table():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS mfa 
            (
                id INTEGER PRIMARY KEY,
                steam_id INTEGER,
                telegram_id INTEGER,
                chat_id INTEGER,
                message_id INTEGER,
                confirmed INTEGER,
                submitted_on INTEGER,
                pending_removal INTEGER
            )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def init_pending_queries_table():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS pending_queries 
            (
                id INTEGER PRIMARY KEY,
                query_type TEXT,
                db_path TEXT,
                query TEXT,
                pending INTEGER,
                chat_id INTEGER,
                message_id INTEGER
            )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        init_reform_table()
        init_players_table()
        init_sessions_table()
        init_mfa_table()
        init_pending_queries_table()
    except Exception as e:
        logger(e, "ERROR")

########################################
### DB FUNCTIONS
########################################

def get_pending_rename_data(get_fake_message=False):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT id, query, chat_id, message_id FROM pending_queries WHERE query_type = 'rename' AND pending = 1")
        pending = c.fetchall()
        if pending:
            import re
            data = []
            pattern = r"UPDATE \w+ SET username = '([^']+)' WHERE username = '([^']+)' AND steam_id = (\d+)"
            for ID, query, chat_id, message_id in pending:
                match = re.match(pattern, query)
                if match:
                    new_username = match.group(1)
                    old_username = match.group(2)
                    steam_id = int(match.group(3))
                    if not get_fake_message:
                        data.append([ID, old_username, new_username, steam_id])
                    else:
                        data.append([ID, old_username, new_username, steam_id, fake_message(chat_id, message_id)])
            return data
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def sync_with_server_whitelist():
    try:
        import sqlite3
        from datetime import datetime
        TEMP_DB = os.path.join(THIS_FOLDER, "tmp.db")
        # Need to copy to another file to open it since it's already open by the game. Also safer to touch just the copy.
        run_command(f'cp {ZOMBOID_SERVER_DB} {TEMP_DB}')
        # Let's open the bot DB
        pztg_db = sqlite3.connect(pztgdb)
        c = pztg_db.cursor()
        # And attach the game DB to make use of more efficient sorting functions even if we don't realistically really need it
        c.execute(f"ATTACH DATABASE '{TEMP_DB}' AS game_server_db")
        c.execute('''
            SELECT w.username, w.banned, w.lastconnection, w.steamid, w.accesslevel 
            FROM game_server_db.whitelist w
            LEFT JOIN players p ON w.username = p.username AND w.steamid = p.steam_id
            WHERE p.steam_id IS NULL and w.steamid IS NOT NULL''')
        missing_entries = c.fetchall()
        c.execute('''
            SELECT w.username, w.lastconnection, w.steamid
            FROM game_server_db.whitelist w
            LEFT JOIN players p ON w.username = p.username AND w.steamid = p.steam_id
            WHERE p.lastconnection <> w.lastconnection''')
        latest_connections = c.fetchall()
        # Add missing entries to the players table
        for entry in missing_entries:
            username, banned, lastconnection, steamid, accesslevel = entry
            firstconnection = log_timestamp()
            # Check if there is a corresponding telegramid in the mfa table
            c.execute("SELECT telegram_id FROM mfa WHERE steam_id = ? AND confirmed = 1", (steamid,))
            result = c.fetchone()
            if result:
                telegramid = result[0]
            else:
                telegramid = None
            # Finally, insert the entry into the players table
            c.execute('''
                INSERT INTO players (username, banned, accesslevel, firstconnection, lastconnection, steam_id, telegram_id)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (username, banned, accesslevel, firstconnection, lastconnection, steamid, telegramid))
        for entry in latest_connections:
            username, lastconnection, steamid = entry
            c.execute('''
                UPDATE players SET lastconnection = ? WHERE steam_id = ? AND username = ?
            ''', (lastconnection, steamid, username))
        # Check if there's any conflict between a new username and an existing pending rename request
        c.execute('SELECT username FROM players')
        player_usernames = c.fetchall()
        pending = get_pending_rename_data(get_fake_message=True)
        if pending:
            for ID, pending_old_username, pending_new_username, pending_steam_id, fake_message in pending:
                if any(pending_new_username == username for username in player_usernames):
                    c.execute("DELETE FROM pending_queries WHERE id = ?", (ID,))
                    reply_to(fake_message, "Another user logged in with the username you wanted to use before reboot. Request canceled.")
        # Commit the changes and close the connection
        pztg_db.commit()
        pztg_db.close()
        # And clean by removing the temporary copy
        rm(TEMP_DB)
    except Exception as e:
        logger(e, "ERROR")

def add_to_pending_queries(query_type, db_path, query, chat_id, message_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("INSERT INTO pending_queries (query_type, db_path, query, pending, chat_id, message_id) VALUES (?, ?, ?, 1, ?, ?)", (query_type, db_path, query, chat_id, message_id))
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def execute_query(db_path, query):
    try:
        import sqlite3
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        c.execute(query)
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger(e, "ERROR")    

def run_pending_queries():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT id, db_path, query FROM pending_queries WHERE pending = 1 ")
        queries = c.fetchall()
        for ID, db_path, query, query_type in queries:
            execute_query(db_path, query)
            c.execute("UPDATE pending_queries SET pending = 0 WHERE ID = ?", (ID,))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger(e, "ERROR")   

def delete_pending_rename(username, steam_id):
    try:
        pending = get_pending_rename_data()
        if get_pending_rename_data():
            import sqlite3
            conn = sqlite3.connect(pztgdb)
            c = conn.cursor()
            for ID, pending_old_username, pending_new_username, pending_steam_id in pending:
                if pending_old_username == username and pending_steam_id == steam_id:
                    c.execute("DELETE FROM pending_queries WHERE id = ?", (ID,))
                    deleted = True
            conn.commit()
            conn.close()
            return deleted
    except Exception as e:
        logger(e, "ERROR")

def submit_mfa_registration(steam_id, telegram_id, message):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('INSERT INTO mfa (steam_id, telegram_id, chat_id, message_id, confirmed, submitted_on) VALUES (?, ?, ?, ?, ?, ?)', (int(steam_id), int(telegram_id), int(message.chat.id), int(message.id), 0, unix_timestamp()))
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def player_set_telegram_id(steam_id, telegram_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT * FROM players WHERE steam_id = ?", (int(steam_id),))
        existing_player = c.fetchone()
        if existing_player:
            c.execute("UPDATE players SET telegram_id = ? WHERE steam_id = ?", (int(telegram_id), int(steam_id)))
            conn.commit()
            conn.close()
            return True
        conn.close()
        return False
    except Exception as e:
        logger(e, "ERROR")

def confirm_mfa_registration(steam_id, username, telegram_id):
    try:
        import sqlite3
        global MFA
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute(f'UPDATE mfa SET confirmed = 1, pending_removal = 1 WHERE steam_id = {int(steam_id)} AND telegram_id = {int(telegram_id)}')
        c.execute(f'UPDATE players SET telegram_id = {telegram_id} WHERE steam_id = {steam_id}')
        conn.commit()
        conn.close()
        pending_query_type = 'mfa'
        add_to_pending_queries(pending_query_type, ZOMBOID_SERVER_DB, "DELETE FROM whitelist WHERE steam_id = ? AND username = ?", (steam_id, username))
        add_to_pending_queries(pending_query_type, ZOMBOID_PLAYER_DB, "DELETE FROM networkPlayers WHERE steam_id = ? AND username = ?", (steam_id, username))
        add_to_pending_queries(pending_query_type, pztgdb, "DELETE FROM players WHERE steam_id = ? AND username = ?", (steam_id, username))
        add_to_pending_queries(pending_query_type, pztgdb, "UPDATE mfa SET pending_removal = 0 WHERE steam_id = ? AND telegram_id = ?", (steam_id, telegram_id))
    except Exception as e:
        logger(e, "ERROR")

def get_mfa_registrants():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT steam_id, telegram_id, chat_id, message_id, confirmed FROM mfa WHERE confirmed = 0 OR pending_removal = 1")
        results = c.fetchall()
        MFA = []
        for steam_id, telegram_id, chat_id, message_id, confirmed in results:
            MFA.append([steam_id, telegram_id, fake_message(chat_id, message_id), confirmed])
        conn.close()
        return MFA
    except Exception as e:
        logger(e, "ERROR")

def save_reform(reform):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        # Check if the reform already exists in the table
        c.execute('SELECT * FROM reforms WHERE reform_id = ?', (reform.reform_id,))
        existing_reform = c.fetchone()
        if existing_reform:
            # Reform exists, update it
            update_columns = ', '.join([f"{col} = ?" for col in reform.__dict__.keys()])
            update_values = tuple(reform.__dict__.values()) + (reform.reform_id,)  # Include reform_id for WHERE clause
            c.execute(f'UPDATE reforms SET {update_columns} WHERE reform_id = ?', update_values)
        else:
            # Reform does not exist, insert it
            columns = ', '.join([col for col in reform.__dict__.keys()])
            placeholders = ', '.join(['?' for _ in range(len(reform.__dict__))])
            values = tuple(reform.__dict__.values())
            c.execute(f'INSERT INTO reforms ({columns}) VALUES ({placeholders})', values)
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def get_player(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT * FROM players WHERE steam_id = ?', (int(steam_id),))
        result = c.fetchone()
        conn.close()
        if result:
            return Player(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_player_list():
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT username FROM players')
        result = c.fetchall()
        conn.close()
        return result
    except Exception as e:
        logger(e, "ERROR")

def get_reform(reform_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE reform_id = ?', (int(reform_id),))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_reform_by_poll_id(poll_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE poll_id = ?', (int(poll_id),))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_mod_clone_change(modid, workshopid, action):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE change_mod_modid = ? AND change_mod_workshopid = ? AND change_mod_action = ? AND reform_is_active = ?', (modid, int(workshopid), action, 1))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def get_setting_clone_change(variable, new_value):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE change_setting_variable = ? AND change_setting_new_value = ? AND reform_is_active = ?', (variable, new_value, 1))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def player_get_telegram_id(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute('SELECT telegram_id FROM players WHERE steam_id = ?', (int(steam_id),))
        result = c.fetchone()
        conn.close()
        if result:
            return result[0]
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def user_is_registered(telegram_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT steam_id FROM mfa WHERE telegram_id=? AND confirmed=?", (int(telegram_id),1))
        steam_id = c.fetchone()
        conn.close()
        return steam_id[0] if steam_id else False
    except Exception as e:
        logger(e, "ERROR")

def  player_is_registered(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("SELECT telegram_id FROM mfa WHERE steam_id=? AND confirmed=?", (int(steam_id),1))
        telegram_id = c.fetchone()
        conn.close()
        return telegram_id[0] if telegram_id else False
    except Exception as e:
        logger(e, "ERROR")

def session_open(steam_id, ip):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("INSERT INTO sessions (steam_id, login, ip) VALUES (?, ?, ?)", (int(steam_id), unix_timestamp(), ip))
        session_id = c.lastrowid
        conn.commit()
        conn.close()
        return session_id
    except Exception as e:
        logger(e, "ERROR")

def session_close(session_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()
        c.execute("UPDATE sessions SET logout = ? WHERE session_id = ?", (unix_timestamp(), int(session_id)))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger(e, "ERROR")

def get_player_stats(telegram_id):
    pass

def get_user_activity_info(telegram_id):
    try:
        import sqlite3
        conn = sqlite3.connect(pztgdb)
        c = conn.cursor()

        # Get steam_id associated with the provided telegram_id
        c.execute("SELECT steam_id, firstconnection FROM players WHERE telegram_id=?", (telegram_id,))
        steam_id, firstconnection = c.fetchone()
        firstconnection = log_timestamp_to_unix_timestamp(firstconnection)

        # Get count of logins, total time connected, and average session duration
        c.execute("SELECT COUNT(*), SUM(logout - login), AVG(logout - login) FROM sessions WHERE steam_id=?", (steam_id,))
        login_count, total_time_connected, avg_session_duration = c.fetchone()

        # Get the number of reforms proposed by the user
        c.execute("SELECT COUNT(*) FROM reforms WHERE proposer_id=?", (telegram_id,))
        proposed_reforms_count = c.fetchone()[0]

        # Get the number of proposed reforms that got implemented
        c.execute("SELECT COUNT(*) FROM reforms WHERE proposer_id=? AND reform_implemented=1", (telegram_id,))
        implemented_reforms_count = c.fetchone()[0]

        # Get the number of times the user voted yes, no, and didn't vote
        c.execute("SELECT poll_yes_list, poll_no_list, reform_date FROM reforms")
        reforms_data = c.fetchall()

        voted_yes_count = 0
        voted_no_count = 0
        did_not_vote_count = 0
        poll_count = 0

        for poll_yes_list, poll_no_list, reform_date in reforms_data:
            # Check if the user could have possibly voted based on their join date
            if firstconnection <= reform_date:
                poll_yes_list = poll_yes_list.split(",") if poll_yes_list else []
                poll_no_list = poll_no_list.split(",") if poll_no_list else []
                poll_count += 1
                # Check if user's telegram_id is in yes list
                if str(telegram_id) in poll_yes_list:
                    voted_yes_count += 1
                # Check if user's telegram_id is in no list
                elif str(telegram_id) in poll_no_list:
                    voted_no_count += 1
                else:
                    did_not_vote_count += 1

        # Close connection
        conn.close()

        voted_yes_perc = (voted_yes_count / poll_count * 100) if poll_count != 0 else 0
        voted_no_perc = (voted_no_count / poll_count * 100) if poll_count != 0 else 0
        did_not_vote_perc = (did_not_vote_count / poll_count * 100) if poll_count != 0 else 0
        reforms_approved_perc = round(implemented_reforms_count/proposed_reforms_count*100) if proposed_reforms_count != 0 else 0

        return f'''<b>Login count</b>: {login_count}
<b>Total time played</b>: {format_time(total_time_connected, 'm')}
<b>Average session</b>: {format_time(avg_session_duration, 'm')}

<b>Zombie Killed:</b> {'2'}

<b>Reforms proposed</b>: {proposed_reforms_count} ({reforms_approved_perc}% approved)

Out of {poll_count} polls, you voted:
<b>Yes</b>: {voted_yes_count} ({round(voted_yes_perc)}%) - <b>No</b>: {voted_no_count} ({round(voted_no_perc)}%) - <b>Blank</b>: {did_not_vote_count} ({round(did_not_vote_perc)}%)'''

    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### COMMAND SETUP & COMMAND RELATED
########################################################################################################################

### COMMANDS - FUNCTIONS

def add_cmd(command_list, cmd, description):
    try:
        from telebot import types
        #print("CMD: "+cmd+" ("+str(len(cmd))+")")
        #print("DESC: "+description+" ("+str(len(description))+")\n")
        command_list.append(types.BotCommand(command=str(cmd), description=str(description)))
        return True
    except Exception as e:
        logger(e, "ERROR")

def add_cmd_bulk(command_list, cmd_list):
    try:
        from telebot import types
        for cmd, description in cmd_list:
            add_cmd(command_list, cmd, description)
        return command_list
    except Exception as e:
        logger(e, "ERROR")

def init_commands():
    try:
        command_list = []
        return add_cmd_bulk(command_list, [[start_cmd,start_desc],[restart_cmd,restart_desc],[status_cmd,status_desc],[stats_cmd,stats_desc],[compare_cmd,compare_desc],[mod_cmd,mod_desc],[setting_cmd,setting_desc],[rename_cmd,rename_desc],[register_cmd,register_desc],[help_cmd,help_desc]])
    except Exception as e:
        logger(e, "ERROR")

### COMMAND - MESSAGES

if __name__ == '__main__':
    start_cmd='start'
    start_desc='Display bot welcome message.'
    start_msg='Hi, I am Rotting Ghoul! I can automatically get you updates on the status of the PZserver.'
    status_cmd='status'
    status_desc='Retrive the current status of '+SERVICE_NAME
    set_default_cmd='default'
    set_default_msg_helper='Use /default to set the current settings as default settings'
    compare_cmd='diff'
    compare_desc='Shows differences between current settings and vanilla'
    compare_msg_helper='Shows variances between current and vanilla'
    restart_cmd='restart'
    restart_confirm_cmd='confirm'
    restart_cancel_cmd='cancel'
    restart_desc='Restart the application'
    restart_msg="Are you really sure you want to restart the server? All users will be disconnected.\n\nPlease press: /"+restart_confirm_cmd+" to proceed.\n\nOr press: /"+restart_cancel_cmd+" to cancel."
    log_cmd = 'log'
    log_desc = 'Filters the log of this bot'
    log_msg_helper ='''To filter the logs, please use:
        /'''+log_cmd+''' <keyword>'''
    stats_cmd='stats'
    stats_desc='Display account stats of a registered account'
    stats_msg_helper='''To see your stats use /'''+stats_cmd+''' or:
        /'''+stats_cmd+''' <steam id>  [for another player]'''
    mod_cmd='mod'
    mod_desc='Manage installed mods through polls'
    mod_msg_helper='''To use '''+mod_cmd+''' command please use:
        /'''+mod_cmd+''' list
        /'''+mod_cmd+''' install <Mod URL>
        /'''+mod_cmd+''' install <Mod ID> <Workshop ID>
        /'''+mod_cmd+''' uninstall <Mod URL>
        /'''+mod_cmd+''' uninstall <Mod ID>
        /'''+mod_cmd+''' uninstall <Mod ID> <Workshop ID>'''
    setting_cmd='setting'
    setting_desc='Manage server settings through polls'
    setting_msg_helper='''To use '''+setting_cmd+''' command please use:
        /'''+setting_cmd+''' get <parameter>
        /'''+setting_cmd+''' set <parameter> <value>'''
    rename_cmd='rename'
    rename_desc='Renames a selected character in game'
    rename_msg_helper='''To use '''+rename_cmd+''' command please use (use double quotes):
        /'''+rename_cmd+''' "<old username>" "<new username>"'''
    register_cmd='register'
    register_desc='Link the game account with your telegram account'
    register_msg_helper='''To link your game account and use /'''+stats_cmd+''' please use:
        /'''+register_cmd+''' <your steam id>
        
How to find your steam ID:
https://help.steampowered.com/en/faqs/view/2816-BE67-5B69-0FEC'''
    help_cmd='help'
    help_desc='Provide the command legenda.'
    help_msg='List of the commands:\n/'+help_cmd+': '+help_desc+'''
/'''+restart_cmd+': '+restart_desc+'''
/'''+status_cmd+': '+status_desc+'''
/'''+compare_cmd+': '+compare_msg_helper+'\n'+mod_msg_helper+'\n'+setting_msg_helper+'\n'+stats_msg_helper+'\n'+log_msg_helper+'\n'+rename_msg_helper+'\n'+register_msg_helper

    ### OTHER MESSAGES

    strip_modid_from_url_failed = "Getting modID from steam URL failed. Try using legacy syntax."
    not_a_workshop_url = "The URL you provided has not been recognized as a valid workshop URL. Try the legacy syntax maybe?"
    already_installed_msg = "The mod you want to install is already installed."
    msg_mod_not_installed = "The mod you want to uninstall is not installed"
    msg_modid_invalid = "The mod ID entered are being considered invalid."
    msg_no_mods_installed = "There are no mods installed."
    msg_unhandled_exception = "Unhandled exception, check logs, call the police or contact the administrator."
    msg_workshopid_from_file_failed = "Getting the workshop ID from the config file failed. Check logs."
    msg_only_master = "Only my master can use this. You have no power here."
    msg_change_implemented = "This change has been implemented."
    msg_change_rejected = "This change has been rejected."

### INITIALIZE BOT COMMANDS

if __name__ == '__main__':
    try:
        commands = init_commands()
        if commands:
            bot.set_my_commands(commands)
    except Exception as e:
        logger(e, "ERROR")
 
### COMMANDS - RESTART DOUBLE CHECK - no database, just memory

global_restart_requests = []

def save_restart(restart_cmd, user):
    try:
        global global_restart_requests
        for each in global_restart_requests:
            if each[1] == user:
                each[0] = restart_cmd
                return
        global_restart_requests.append((restart_cmd, user))        
    except Exception as e:
        logger(e, "ERROR")

def check_restart(restart_cmd, user):
    try:
        global global_restart_requests
        for each in global_restart_requests:
            if each[0] == restart_cmd and each[1] == user:
                return True
        return False
    except Exception as e:
        logger(e, "ERROR")

def clear_restart(user):
    try:
        global global_restart_requests
        temp = global_restart_requests
        for each in global_restart_requests:
            if each[1] == user:
                temp.remove(each)
                removed = True
        global_restart_requests = temp
        if removed:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### GAME RUNTIME LOG PARSING MANAGER
########################################################################################################################

### PARSING FLAGS & CONSTANTS

if __name__ == '__main__':
    open_sessions = []
    
    command_flag = True
    join_flag = True
    left_flag = True
    mod_fail_flag = True

    log_key_client_re_pattern = r'ip=([\d.]+)\s.*?steam-id=(\d+)\s.*?(?:access=(\w+)\s)?username="([^"]+)"'
    mod_fail_re_pattern = r'required mod "(.*?)" not found'

    log_key_start = '*** SERVER STARTED ****'
    log_key_stop = 'command entered via server console (System.in): "quit"'
    log_key_client_init = ['[receive-packet] "client-connect"','steam-id','username']
    log_key_client_connecting = ['[receive-packet] "login-queue-request"','steam-id','username']
    log_key_client_connected = ['[receive-packet] "login-queue-done"','steam-id','username']
    log_key_player_connected = ['receive-packet] "player-connect"','steam-id','username']
    log_key_player_in_game = ['[fully-connected]','steam-id','username']
    log_key_client_logout = ['[disconnect]','steam-id','username']
    log_key_cmd = 'command entered'
    log_key_death = 'replacing dead player'
    log_key_mod_fail = ['ZomboidFileSystem.loadModAndRequired','not found']

########################################
### MFA RELATED
########################################

def mfa_naming_convention(telegram_id):
    return f"MFA{str(telegram_id)}"

def kick_player(username, msg):
    try:
        run_command(f"tmux send-keys -t {SERVICE_NAME} 'kickuser {username} -r \"{msg}\"' C-m")
    except Exception as e:
        logger(e, "ERROR")

def multi_fucker_autentication(steam_id, username, login):
    try:
        MFA = get_mfa_registrants()
        if MFA:
            for mfa_steam_id, mfa_telegram_id, message, confirmed in MFA:
                if username == mfa_naming_convention(mfa_telegram_id) and steam_id == mfa_steam_id:
                    if not confirmed:
                        MFA.append(username)
                        confirm_mfa_registration(steam_id, username, mfa_telegram_id)
                        msg = f"Your game account has been successfully linked with telegram. The account \"{username}\" will be deleted on next reboot."
                        reply_to(message, msg)
                    return True             
        return False
    except Exception as e:
        logger(e, "ERROR")

########################################
### LOGIN/LOGOUT FUNCTIONS
########################################

def player_client_login_event(steam_id, username, ip, accesslevel='user'):
    try:
        global open_sessions
        if not multi_fucker_autentication(steam_id, username, 1):
            sync_with_server_whitelist()
            session = Session()
            session.steam_id = steam_id
            session.id = session_open(steam_id, ip)
            open_sessions.append(session)
            return True
    except Exception as e:
        logger(e, "ERROR")
        
def player_client_logout_event(steam_id, username, ip, accesslevel='user'):
    try:
        global open_sessions
        if not multi_fucker_autentication(steam_id, username, 0):
            sync_with_server_whitelist()
            if open_sessions:
                for session in open_sessions:
                    if session.steam_id == steam_id:
                        session_close(session.id)
                        open_sessions.pop(open_sessions.index(session))
            else:
                logger("No open sessions, yet a player logged out.", "ERROR")
            return True
    except Exception as e:
        logger(e, "ERROR")

########################################
### PARSING FUNCTIONS
########################################

def alert_bot(keyword, line):
    try:
        #print(keyword)
        #print(line)
        import re
        if keyword == log_key_start:
            msg = SERVICE_NAME.capitalize()+" started."
            logger(msg, "INFO")
            server_chat_message(msg)
            #if not changes_are_applied():
            #    server_chat_message("Seems like some changes were not applied since last reboot. Check logs for more info.")
        elif keyword == log_key_stop:
            msg = SERVICE_NAME.capitalize()+" stopped."
            logger(msg, "INFO")
            server_chat_message(msg)
        elif mod_fail_flag and keyword == log_key_mod_fail:
            match = re.search(mod_fail_re_pattern, line)
            msg = f"Mod \"{match.group(1)}\" failed to load while starting the server"
            logger(msg, "INFO")
            server_chat_message(msg)
        elif command_flag and keyword == log_key_cmd:
            if '"quit"' not in line and '"save"' not in line and 'kickuser MFA' not in line:
                index = line.find('command entered')
                msg = line[index:].capitalize()
                logger(msg, "INFO")
                cheat_alert(msg)
        elif join_flag and keyword == log_key_client_init:
            match = re.search(log_key_client_re_pattern, line)
            if match:
                ip = match.group(1)
                steam_id = int(match.group(2))
                accesslevel = match.group(3)
                username = match.group(4)
                if player_client_login_event(steam_id, username, ip):
                    msg = f"A player connected to the server: {username}"
                    logger(msg, "INFO")
                    server_chat_message(msg)
        elif left_flag and keyword == log_key_client_logout:
            match = re.search(log_key_client_re_pattern, line)
            if match:
                ip = match.group(1)
                steam_id = int(match.group(2))
                accesslevel = match.group(3)
                username = match.group(4)
                if player_client_logout_event(steam_id, username, ip):
                    msg = f"A player disconnected from the server: {username}"
                    logger(msg, "INFO")
                    server_chat_message(msg)
    except Exception as e:
        logger(e, "ERROR")

def monitor_log(filename=SERVICE_LOG, keywords=[log_key_start, log_key_stop, log_key_client_init, log_key_client_logout, log_key_cmd, log_key_mod_fail]):
    try:
        import subprocess
        run_command(f"> {filename}")
        tail_process = subprocess.Popen(['tail', '-f', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        for line in tail_process.stdout:
            # Process each line as it is received
            for keyword in keywords:
                if isinstance(keyword, str):
                    if keyword in line:
                        alert_bot(keyword, line)
                elif isinstance(keyword, list):
                    if all(key_fragment in line for key_fragment in keyword):
                        alert_bot(keyword, line)
    except Exception as e:
        logger(e, "ERROR")

### START PARSING
if __name__ == '__main__':
    try:
        import threading
        pzserver_monitor_log_thread = threading.Thread(target=monitor_log)
        pzserver_monitor_log_thread.start()
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### VANILLA SETTINGS GENERATION
########################################################################################################################

def vanilla_monitor_log(filename=VANILLA_LOG_FILE, keywords=[log_key_start,log_key_stop]):
    try:
        import subprocess
        run_command("> "+VANILLA_LOG_FILE)
        tail_process = subprocess.Popen(['tail', '-f', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)    
        for line in tail_process.stdout:
            for keyword in keywords:
                if keyword in line:
                    if keyword == log_key_start:
                        vanilla_started_event.set()
                        run_command("tmux send-keys -t "+VANILLA_SERVER_NAME+" \"quit\" C-m")
                    if keyword == log_key_stop:
                        vanilla_exit_event.set()
                        break
    except Exception as e:
        logger(e, "ERROR")

def start_vanilla_server():
    try:
        VANILLA_SERVER_CMD_START = os.path.join(SERVICE_FOLDER, "start-server.sh")+" -servername "+VANILLA_SERVER_NAME+" | tee "+VANILLA_LOG_FILE
        VANILLA_TMUX_SESSION_START = "tmux new-session -d -s "+VANILLA_SERVER_NAME+" \""+VANILLA_SERVER_CMD_START+"\""
        run_command(VANILLA_TMUX_SESSION_START)
    except Exception as e:
        logger(e, "ERROR")

def stop_vanilla_server():
    try:
        vanilla_monitor_log_thread = threading.Thread(target=vanilla_monitor_log)
        vanilla_monitor_log_thread.start()
    except Exception as e:
        logger(e, "ERROR")

def tmux_session_is_still_open(tmux_session_name):
    try:
        command = f"tmux list-sessions | grep {tmux_session_name}"
        output = run_command(command)
        if output:
            return True
        return False
    except Exception as e:
        logger(e, "ERROR")
        return False

def regenerate_vanilla_settings():
    try:
        import time
        global vanilla_settings
        global vanilla_started_event
        global vanilla_exit_event
        global vanilla_settings_event
        vanilla_settings = 425
        rm(VANILLA_SERVERINI_PATH)
        rm(VANILLA_SANDBOXVARS_PATH)
        start_vanilla_server()
        stop_vanilla_server()
        vanilla_started_event.wait()
        temp_vanilla_settings = get_settings(VANILLA_SERVERINI, VANILLA_SANDBOXVARS)
        Mods = get_setting('Mods').value
        WorkshopItems = get_setting('WorkshopItems').value
        set_setting_value('Mods', Mods, temp_vanilla_settings)
        set_setting_value('WorkshopItems', WorkshopItems, temp_vanilla_settings)
        vanilla_exit_event.wait()
        counter = 0
        while True:
            vanilla_started_event = threading.Event()
            vanilla_exit_event = threading.Event()
            if not tmux_session_is_still_open(VANILLA_SERVER_NAME):
                start_vanilla_server()
                stop_vanilla_server()
                vanilla_started_event.wait()
                vanilla_settings = get_settings(VANILLA_SERVERINI, VANILLA_SANDBOXVARS)
                vanilla_settings_event.set()
                break
            else:
                time.sleep(1)
                counter += 1
                if counter == 60:
                    w = "Vanilla setting generation is taking more than expected. Check the logs and the vanilla tmux session?"
                    print(w)
                    logger(w, "WARNING")
    except Exception as e:
        vanilla_settings = 500
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        vanilla_settings = get_settings(VANILLA_SERVERINI, VANILLA_SANDBOXVARS)
        vanilla_started_event = threading.Event()
        vanilla_exit_event = threading.Event()
        vanilla_settings_event = threading.Event()
        regenerate_setting_thread = threading.Thread(target=regenerate_vanilla_settings)
        if AUTOUPDATE_VANILLA_SETTINGS_ON_START == 1:
            regenerate_setting_thread.start()
        elif AUTOUPDATE_VANILLA_SETTINGS_ON_START == 2:
            if get_setting('Mods').value != get_setting('Mods', source_settings=vanilla_settings).value or not vanilla_settings:
                regenerate_setting_thread.start()
        else:
            if not vanilla_settings:
                vanilla_settings = 404
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### POLLING MANAGER & MONITOR
########################################################################################################################

def create_poll(chat_id, description, options, anonymous=False, multiple_answers=False):
    try:
        poll = bot.send_poll(chat_id, question=description, options=options, is_anonymous=anonymous, allows_multiple_answers=multiple_answers)
        return poll
    except Exception as e:
        logger(e, "ERROR")

def stop_poll(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        reform.poll_stop_date = unix_timestamp()
        save_reform(reform)
        return bot.stop_poll(reform.reform_chat_id, reform.poll_message_id)
    except Exception as e:
        logger(e, "ERROR")

def deny_change(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        reform.reform_is_active = 0
        reform.reform_implemented = 0
        save_reform(reform)
        #reform.print_all()
        reply_to(fake_message(reform.reform_chat_id, reform.poll_message_id), msg_change_rejected)
    except Exception as e:
        logger(e, "ERROR")

def implement_change(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        if reform.change_ctype == 'mod':
            if reform.change_mod_action == 'install':
                install_mod(reform.change_mod_modid, reform.change_mod_workshopid)
            elif reform.change_mod_action == 'uninstall':
                uninstall_mod(reform.change_mod_modid, reform.change_mod_workshopid)
            logger(f"Type: {reform.change_ctype} Action: {reform.change_mod_action} ModID: {reform.change_mod_modid} WorkshopID: {reform.change_mod_workshopid} Date: {log_timestamp}", "INFO")
        elif reform.change_ctype == 'setting':
            logger(f"Type: {reform.change_ctype} Variable: {reform.change_setting_variable} Old Value: {reform.change_setting_old_value} Current Value: {get_setting(reform.change_setting_variable).value} New Value: {reform.change_setting_new_value} Date: {log_timestamp}", "INFO")
            set_setting_value(reform.change_setting_variable, reform.change_setting_new_value)
        reform.reform_is_active = 0
        reform.reform_implemented = 1
        save_reform(reform)
        #reform.print_all()
        reply_to(fake_message(reform.reform_chat_id, reform.poll_message_id), msg_change_implemented)
    except Exception as e:
        logger(e, "ERROR")

def consensus(reform=None, poll_id=None, votes_from = 'db', consensus = False, virdict = None):
    try:
        if votes_from == 'db':
            if not reform:
                reform = get_reform_by_poll_id(poll_id)
        max_voters = bot.get_chat_members_count(reform.reform_chat_id) - 1 # At least one bot (this one) is in the count, so we detract one.
        if reform.poll_options == 2:
            consensus_threshold = max_voters // reform.poll_options + 1 # Majority threshold (for testing remove the +1 and be alone in a group with just the bot)
        if votes_from == 'db':
                if reform.poll_yes_list:
                    yes_votes = len(reform.poll_yes_list.split(','))
                else:
                    yes_votes = 0
                if reform.poll_no_list:
                    no_votes = len(reform.poll_no_list.split(','))
                else:
                    no_votes = 0
                if yes_votes >= consensus_threshold:
                    consensus, virdict = (True, True)
                    reform.poll_consensus_coefficient = yes_votes / consensus_threshold
                elif no_votes >= consensus_threshold:
                    consensus, virdict = (True, False)
                    reform.poll_consensus_coefficient = no_votes / consensus_threshold
        elif votes_from == 'tg':
            pass
        if consensus:
            if virdict:
                implement_change(reform)
            else:
                deny_change(reform)
            stop_poll(reform)
            return (consensus, virdict)
        else:
            return (consensus, virdict)
        save_reform(reform)
    except Exception as e:
        logger(e, "ERROR")
        
def update_poll_vote(voter, poll_id, votes):
    try:
        reform = get_reform_by_poll_id(poll_id)
        if reform.poll_options == 2:
            yes_option_n = 0
            no_option_n = 1
            voter = str(voter)
            is_yes_list = False
            is_no_list = False
            if len(votes) > 0:
                if votes[0] == yes_option_n:
                    is_yes_list = True
                    if reform.poll_yes_list == "":
                        reform.poll_yes_list = voter
                    else:
                        yes_array = reform.poll_yes_list.split(',')
                        yes_array.append(voter)
                        reform.poll_yes_list = ','.join(map(str, ensure_max_occurrences(yes_array, voter, 1)))
                elif votes[0] == no_option_n:
                    is_no_list = True
                    if reform.poll_no_list == "":
                        reform.poll_no_list = voter
                    else:
                        no_array = reform.poll_no_list.split(',')
                        no_array.append(voter)
                        reform.poll_no_list = ','.join(map(str, ensure_max_occurrences(no_array, voter, 1)))
            else: # retract_vote_option
                if reform.poll_yes_list:
                    vote_list = reform.poll_yes_list.split(',')
                    reform.poll_yes_list = ','.join(map(str, ensure_max_occurrences(vote_list, voter, 0)))
                if reform.poll_no_list:
                    vote_list = reform.poll_no_list.split(',')
                    reform.poll_no_list = ','.join(map(str, ensure_max_occurrences(vote_list, voter, 0)))
            #print("--------------------------------------------------------------")
            #reform.print_all()
            #print("--------------------------------------------------------------")
            save_reform(reform)
            consensus(reform)
    except Exception as e:
        logger(e, "ERROR")

def active_clone_changes(ctype, change):
    try:
        if ctype == 'mod':
            action, modid, workshopid = change
            return get_mod_clone_change(modid, workshopid, action)
        elif ctype == 'setting':
            variable, value = change
            return get_setting_clone_change(variable, value)
    except Exception as e:
        logger(e, "ERROR")

def mod_poll_launch(new_reform, workshop_url):
    try:
        poll = create_poll(new_reform.reform_chat_id, new_reform.reform_name, ['Yes','No'])
        reply_to(poll, workshop_url)
        return poll
    except Exception as e:
        logger(e, "ERROR")

def mod_poll_img(new_reform, workshop_url):
    try:
        get_steam_image_url = strip_img_url_from_steam(workshop_url) 
        bot.send_photo(new_reform.reform_chat_id, get_steam_image_url)
        return True
    except Exception as e:
        logger(e, "ERROR")

def setting_poll_launch(new_reform):
    try:
        return create_poll(new_reform.reform_chat_id, new_reform.reform_description, ['Yes','No'])
    except Exception as e:
        logger(e, "ERROR")

def create_reform(message, ctype, change):
    try:
        clone = active_clone_changes(ctype, change)
        if not clone:
            import os
            new_reform = Reform()
            new_reform.reform_id = message.id
            new_reform.reform_chat_id = message.chat.id
            new_reform.reform_date = unix_timestamp()
            new_reform.reform_implemented = 0
            new_reform.reform_is_active = 1
            new_reform.proposer_first_name = message.from_user.first_name
            new_reform.proposer_last_name = message.from_user.last_name
            new_reform.proposer_username = message.from_user.username
            new_reform.proposer_id = message.from_user.id
            new_reform.change_ctype = ctype
            if ctype == 'mod':
                action, modid, workshopid = change
                workshop_url = f"https://steamcommunity.com/sharedfiles/filedetails/?id={workshopid}"
                new_reform.change_mod_action = action
                new_reform.change_mod_modid = modid
                new_reform.change_mod_workshopid = workshopid
                new_reform.reform_name = f"{action.capitalize()} {modid}"
                new_reform.reform_description = f"Do you want to {action} <b>{modid}</b>?"
                poll = mod_poll_launch(new_reform, workshop_url)
                poll_img = mod_poll_img(new_reform, workshop_url)
            elif ctype == 'setting':
                variable, value = change
                new_reform.change_setting_variable = variable
                new_reform.change_setting_old_value = get_setting(variable).value
                new_reform.change_setting_new_value = value
                new_reform.reform_name = f"{variable} {value}"
                new_reform.reform_description = f"Do you want to set {variable} = {value}?"
                poll = setting_poll_launch(new_reform)
            new_reform.poll_id = poll.poll.id
            new_reform.poll_message_id = poll.message_id
            new_reform.poll_options = len(poll.poll.options)
            #new_reform.print_all()
            save_reform(new_reform)
        else:
            if message.chat.id != clone.reform_chat_id:
                bot.forward_message(chat_id=message.chat.id, from_chat_id=clone.reform_chat_id, message_id=clone.poll_message_id)
                reply_to(message, "This change has been already proposed in another chat and is under trial process.")
            else:
                reply_to(fake_message(clone.reform_chat_id, clone.poll_message_id), "This change has been already proposed and is under trial process.")
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### MAIN - LAUNCH SERVER
########################################################################################################################

def start_game_server():
    try:
        run_pending_queries()
        if run_command(f"{SERVICE_MANAGER} --start"):
            logger(f"Game server was started on tmux session \"{SERVICE_MANAGER}\"", "INFO")
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        import sys
        start_pzserver_flag = '--startserver' in sys.argv
        if start_pzserver_flag:
            if not tmux_session_is_still_open(SERVICE_NAME):
                import threading
                pz_game_server_thread = threading.Thread(target=start_game_server)
                pz_game_server_thread.start()
            else:
                logger(f"The game server tmux session (\"{SERVICE_NAME}\") is already/still up. I won't launch another instance.", "INFO")
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### MAIN - COMMAND HANDLERS
########################################################################################################################

if __name__ == '__main__':
    try:
        # SHOW CHAT ID
        @bot.message_handler(commands=['id'])
        def id_command(message):
            print(f"CHAT ID: {message.chat.id}")
            reply_to(message, f"CHAT ID: {message.chat.id}")
        # START
        @bot.message_handler(commands=[start_cmd])
        def start_command(message):
            reply_to(message, start_msg)
        # HELP
        @bot.message_handler(commands=[help_cmd])
        def help_command(message):
            reply_to(message, help_msg, disable_web_page_preview=True)
        # STATUS
        @bot.message_handler(commands=[status_cmd])
        def status_command(message):
            service_status = check_service_status()
            if service_status:
                status = "active."
            elif not service_status:
                status = "down."
            else:
                status = "???"
            reply_to(message, "The PZserver is currently "+status)
        # SHOW LOG
        @bot.message_handler(commands=[log_cmd])
        def log_command(message):
            command = message.text.split()
            if len(command) == 2:
                text_chunks = split_msg_in_chunks(run_command(f"cat {THIS_LOG_FILE} | grep {command[1]}", log=False))
                for chunk in text_chunks:
                    reply_to(message, chunk, parse_mode='HTML')
            else:
                reply_to(message, log_msg_helper)
        # SHOW DIFF
        @bot.message_handler(commands=[compare_cmd])
        def compare_command(message):
            command = message.text.split()
            if len(command) == 1:
                def send_diff():
                    exclusion_list=['ServerWelcomeMessage','Mods','WorkshopItems','PublicDescription','PublicName','ServerPlayerID','ResetID']
                    text_chunks = compare_settings(global_settings, vanilla_settings, as_text=True, exclusion_list=exclusion_list)
                    print(text_chunks)
                    for chunk in text_chunks:
                        reply_to(message, chunk, parse_mode='HTML')
                    return True
                if vanilla_settings not in [500, 404, 425]:
                    send_diff()
                elif vanilla_settings == 425:
                    reply_to(message, "Vanilla settings are being generated. Please wait.")
                    import threading
                    def send_diff_when_ready():
                        vanilla_settings_event.wait()
                        send_diff()
                    send_diff_later = threading.Thread(target=send_diff_when_ready)
                    send_diff_later.start()
                elif vanilla_settings == 500:
                    reply_to(message, "A error prevented vanilla settings generation.")
                elif vanilla_settings == 404:
                    reply_to(message, "Vanilla settings were not found. Provide the setting file or enable autogeneration.")
            else:
                reply_to(message, compare_msg_helper)
        # SET SETTING DEFAULT
        @bot.message_handler(commands=[set_default_cmd])
        def set_setting_defaults_command(message):
            if member_is_dev(message):
                command = message.text.split()
                if len(command) == 1:
                    run_command(f"cp {serverini[0]} {DEFAULT_serverini[0]}")
                    run_command(f"cp {sandboxvars[0]} {DEFAULT_sandboxvars[0]}")
                    reply_to(message, "New defaults have been set based on current settings")
                else:
                    reply_to(message, set_default_msg_helper)
        # STATS
        @bot.message_handler(commands=[stats_cmd])
        def stats_command(message):
            command = message.text.split()
            if len(command) == 1:
                if user_is_registered(message.from_user.id):
                    reply_to(message, get_user_activity_info(message.from_user.id), parse_mode='HTML')
                else:
                    reply_to(message, "You need to register yourself if you want to see your stats.")
                    reply_to(message, register_msg_helper)
            elif len(command) == 2:
                steam_id = valid_steam_id(command[1])
                if steam_id:
                    telegram_id = player_is_registered(steam_id)
                    if telegram_id:
                        reply_to(message, get_user_activity_info(telegram_id), parse_mode='HTML')
                    else:
                        reply_to(message, "This user is not registered yet.")
                else:
                    reply_to(message, f"This is not a valid steam ID.")
            else:
                reply_to(message, stats_msg_helper, disable_web_page_preview=True)
        # REGISTER
        @bot.message_handler(commands=[register_cmd])
        def register_command(message):
            command = message.text.split()
            if len(command) == 2:
                steam_id = valid_steam_id(command[1])
                if steam_id:
                    if get_player(steam_id):
                        reply_to(message, f"Please connect to PZserver with this username: 'MFA{message.from_user.id}' to complete the process.")
                        submit_mfa_registration(steam_id, message.from_user.id, message)
                    else:
                        reply_to(message, f"This steam ID is not associated to any player of the server yet.")
                else:
                    reply_to(message, f"This is not a valid steam ID.")
            else:
                reply_to(message, register_msg_helper, disable_web_page_preview=True)
        # RENAME
        @bot.message_handler(commands=[rename_cmd])
        def rename_command(message):
            def schedule_rename(new, old, steam_id):
                def rename_query(table, new, old, steam_id):
                    return f"UPDATE {table} SET username = '{new}' WHERE username = '{old}' AND steam_id = {steam_id}"
                pending_query_type = 'rename'
                updated = delete_pending_rename(old, steam_id)
                add_to_pending_queries(pending_query_type, ZOMBOID_SERVER_DB, rename_query('whitelist', new, old, steam_id), message.chat.id, message.id)
                add_to_pending_queries(pending_query_type, ZOMBOID_PLAYER_DB, rename_query('networkPlayers', new, old, steam_id), message.chat.id, message.id)
                add_to_pending_queries(pending_query_type, pztgdb, rename_query('players', new, old, steam_id), message.chat.id, message.id)
                msg = f"Character \"{old}\" will be renamed to \"{new}\" on next reboot unless a new player joins with this username before then."
                if not updated:
                    reply_to(message, msg)
                else:
                    reply_to(message, f"{msg} Previous change has been canceled.")
            steam_id = user_is_registered(message.from_user.id)
            if steam_id:
                import re
                usernames = re.findall(r'"([^"]+)"', message.text)
                forbidden_chars = ['/','?','"','$',"'",'.',';',',']
                if len(usernames) == 2:
                    old  = usernames[0]
                    new = usernames[1]
                    if all(len(username)< 20 for username in usernames):
                        if not any(forbidden in username for username in usernames for forbidden in forbidden_chars):
                            if new not in get_player_list():
                                pending = get_pending_rename_data()
                                if not pending:
                                    schedule_rename(new, old, steam_id)
                                else:
                                    you_are_a_fucker = you_are_late = its_your_lucky_day = False
                                    for ID, old_username, new_username, steam_id in pending:
                                        if new == new_username and old == old_username:
                                            you_are_a_fucker = True
                                        elif new == new_username and old != old_username:
                                            you_are_late = True
                                        else:
                                            its_your_lucky_day = True
                                    if its_your_lucky_day:
                                        schedule_rename(new, old, steam_id)
                                    elif you_are_a_fucker:
                                        reply_to(message, "This request has been already recorded, but it won't be implemented until next reboot.")
                                    elif you_are_late:
                                        reply_to(message, "Another player already submitted a request for this name change before you.")
                            else:
                                reply_to(message, "Character name cannot be the same as one of an existing player.")
                        else:
                            reply_to(message, "Character names cannot include these characters:\n/ ? \" $ ' . , ;")
                    else:
                        reply_to(message, "The maximum lenght of a username is 20 characters")
                else:
                    reply_to(message, rename_msg_helper)
            else:
                reply_to(message, register_msg_helper)                                        
        # RESTART
        @bot.message_handler(commands=[restart_cmd])
        def restart_command(message):
            if member_is_admin(message):
                if check_service_status():
                    save_restart(restart_cmd, message.from_user.id)
                    reply_to(message, restart_msg)
                else:
                    reply_to(message, "The server is currently down.")
        @bot.message_handler(commands=[restart_confirm_cmd])
        def confirm_restart_command(message):
            restart_required = check_restart(restart_cmd, message.from_user.id)
            if restart_required:
                clear_restart(message.from_user.id)
                run_command("sudo systemctl restart "+SERVICE_NAME)
        @bot.message_handler(commands=[restart_cancel_cmd])
        def cancel_restart_command(message):
            clear_restart(message.from_user.id)
        # MOD INSTALL / UNINSTALL
        @bot.message_handler(commands=[mod_cmd])
        def mod_command(message):
            def list_mod_cmd():
                modid_list, workshopid_list = get_valid_modid_workshopid_list()
                if not len(modid_list) and not len(workshopid_list):
                    reply_to(message, msg_no_mods_installed)
                elif not len(modid_list) or not len(workshopid_list):
                    reply_to(message, msg_no_mods_installed)
                    logger("Something must be wrong with the mod lists... Please check the config file.", "WARNING")
                elif len(modid_list) == len(workshopid_list):
                    counter = 0
                    msg_body = ""
                    for modid in modid_list:
                        counter += 1
                        workshopid = workshopid_list[modid_list.index(modid)]
                        msg_body += f"{counter}) <a href='https://steamcommunity.com/sharedfiles/filedetails/?id={workshopid}'>{modid}</a> [{workshopid}]\n"
                    reply_to(message, msg_body, disable_web_page_preview=True, parse_mode='HTML')
            def move_mod(from_, to_):
                modid_list, workshopid_list = get_valid_modid_workshopid_list()
                mods_count = len(modid_list)
                if mods_count == len(workshopid_list) and mods_count > 0:
                    if 0 < from_ <= mods_count and 0 < to_ <= mods_count and from_ != to_:
                        modid_list.insert(to_-1, modid_list.pop(from_-1))
                        workshopid_list.insert(to_-1, workshopid_list.pop(from_-1))
                        modid_list_text = ';'.join(map(str, modid_list))
                        workshopid_list_text = ';'.join(map(str, workshopid_list))
                        set_setting_value('Mods', modid_list_text)
                        set_setting_value('WorkshopItems', workshopid_list_text)
                        list_mod_cmd()
                else:
                    reply_to(message, msg_no_mods_installed)
                    logger("Something must be wrong with the mod lists... Please check the config file.", "WARNING")
            def install_uninstall_mod_cmd(action, valid_IDs, source, force=False):
                if valid_IDs:
                    modid, workshopid = valid_IDs
                    is_installed = mod_is_installed(modid, workshopid)
                    if action == 'install':
                        if not is_installed:
                            if not force:
                                create_reform(message, 'mod', [action, modid, workshopid])
                            else:
                                install_mod(modid, workshopid)
                                reply_to(message, msg_change_implemented)
                        elif is_installed:
                            reply_to(message, already_installed_msg)
                        else:
                            reply_to(message, msg_unhandled_exception)
                    elif action == 'uninstall':
                        if is_installed:
                            if not force:
                                create_reform(message, 'mod', [action, modid, workshopid])
                            else:
                                uninstall_mod(modid, workshopid)
                                reply_to(message, msg_change_implemented)
                        elif not is_installed:
                            reply_to(message, msg_mod_not_installed)
                        else:
                            reply_to(message, msg_unhandled_exception)
                    else:
                        reply_to(message, mod_msg_helper)
                else:
                    if source == 'url':
                        reply_to(message, strip_modid_from_url_failed)
                    elif source == 'command':
                        reply_to(message, msg_modid_invalid)
                    elif source == 'file':
                        reply_to(message,  msg_workshopid_from_file_failed)
                    else:
                        reply_to(message, msg_unhandled_exception)
            def install_uninstall_mod_cmd_handler(command=None, force=False):
                if not command:
                    command = message.text.split()
                if len(command) == 3:
                    if is_workshop_url(command[2]):
                        install_uninstall_mod_cmd(command[1], strip_IDs_from_steam(command[2]), 'url', force)
                    elif command[1] == 'uninstall' and is_modid(command[2]):
                        install_uninstall_mod_cmd(command[1], sort_valid_modid_workshopid(command[2], get_workshopid_from_installed_mods(command[2])), 'file', force)
                    else:
                        reply_to(message, mod_msg_helper)
                elif len(command) == 4:
                    install_uninstall_mod_cmd(command[1], sort_valid_modid_workshopid(command[2], command[3]), 'command', force)
            # Alright...
            command = message.text.split()
            if len(command) in range(2,6):
                if command[1] == 'list' and len(command) == 2:
                    list_mod_cmd()
                elif command[1] in ['install', 'uninstall'] and len(command) in range(2,5):
                    install_uninstall_mod_cmd_handler()
                elif command[1] == 'move' and len(command) == 4 and string_is_integer(command[2]) and string_is_integer(command[3]):
                    move_mod(int(command[2]), int(command[3]))
                elif command[1] == 'force' and len(command) in range(3,6):
                    if member_is_dev(message):
                        command.pop(1)
                        install_uninstall_mod_cmd_handler(command, force=True)
                else:
                    reply_to(message, mod_msg_helper)
            else:
                reply_to(message, mod_msg_helper)
        # MODIFY PZSERVER SETTINGS
        @bot.message_handler(commands=[setting_cmd])
        def setting_command(message, force=False):
            def set_setting_cmd_handler(command, force=False):
                if command[2] in ["ServerWelcomeMessage", "Map", "PublicName", "PublicDescription", "DiscordChannel"]: # Exception List
                    import re
                    if not force:
                        match = re.match(r"/setting set (\w+) (.+)", message.text)
                    else:
                        match = re.match(r"/setting force set (\w+) (.+)", message.text)
                    if match:
                        content = match.group(2)
                        if not force:
                            create_reform(message, 'setting', [command[2], content])
                        else:
                            set_setting_value(command[2], content)
                            reply_to(message, msg_change_implemented)
                    else:
                        reply_to(message, setting_msg_helper)
                elif not force:
                    create_reform(message, 'setting', [command[2], command[3]])
                else:
                    set_setting_value(command[2], command[3])
                    reply_to(message, msg_change_implemented)
            def set_setting_cmd_info_setup(desc, value):
                return f"{desc}\nCurrent Setting: *{value}*"
            # Alright...
            command = message.text.split()
            if len(command) in range(3,6):
                if (len(command) == 3 and command[1] == 'get') or (len(command) == 4 and command[1] == 'set'):
                    if is_setting(command[2]):
                        setting_info = set_setting_cmd_info_setup(get_setting(command[2]).description, get_setting(command[2]).value)
                        if command[1] == 'get':
                            reply_to(message, setting_info)
                        elif command[1] == 'set':
                            set_setting_cmd_handler(command)
                            reply_to(message, setting_info)
                    else:
                        reply_to(message, f"\"*{command[3]}*\" is not a setting of this server.")
                if len(command) == 5 and command[1] == 'force' and command[2] == 'set':
                    if is_setting(command[3]):
                        setting_info = set_setting_cmd_info_setup(get_setting(command[2]).description, get_setting(command[2]).value)
                        member_is_dev = member_is_dev(message)
                        if member_is_dev(message):
                            command.pop(1)
                            set_setting_cmd_handler(command, force=True)
                    else:
                        reply_to(message, f"\"*{command[3]}*\" is not a setting of this server.")
            else:
                reply_to(message, setting_msg_helper)
        # LISTEN FOR UPDATES FROM YOUR NON-ANONYMOUS POLLS
        @bot.poll_answer_handler()
        def poll_vote_event(update):
            update_poll_vote(update.user.id, update.poll_id, update.option_ids)

        ########################################
        ### TELEBOT - START POLLING
        ########################################
        
        log_emendazio()
        bot.infinity_polling()
        
    except Exception as e:
        logger(e, "ERROR")
