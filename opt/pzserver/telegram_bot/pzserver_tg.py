#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.    @@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  ,@@@@@@@@@@@@@@@@@@@@@  @@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@%        @@       @@      @@   /@@&     .@@@     #%    /@@@@  .      @@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@%  /@@  .@&  #@@@@  ,@@,  @&  /@@  .@@  /@.  @@@@@@  *@@@@@, @@      @@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  /@@  ,@@  #@@@%  *@@   @@  (@&  ,@@@@@@  .@@@@@@  *@@@@@  @.    ,&*@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@(  ,@@  #@@  #@@@@, .@@  #@@  (@@*  @@@(/@(  @@@ /@  *@@@@@@%   (. .@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@.  /@@@@@@@@@@@@@@@@@@@@@#@%  %@@@@@@@@@@@@@@@@@@@@@@@@@@@@,  .@@%  @@@@@@@@@@@@@@@@@@@@@@@@@
#@                 @@@@@@@@.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@. @@&&&@@@@@@@@@@@@@@@@@@   (@@@  (@@@@@@@@@@@@@@@@@@@@@@@@@
#                  /@@%     .%@@@@@@@@@@@@@@@@@@@@@@@@@@@*            .@@@@@@@@@@       (@@@(  #@@@@           ,/@@@@@@@@
#      &@@@@@     *@@     .    &@       .@@@@@@@@        @#    /@@@.    &@@@@@          .@@@@.      @%     .*.     %@@@@@
#     &@@@@@      @@,   &@@&    @@       /@@@@@@       ,@@%    %@@@@     #@@,     @@@/    #@@@    .@@@     @@@@*    @@@@@
#    &@@@@@      (@@   .@@@@    /@(      ,@@@@@/       (@@*    (@@@@(    ,@@.    @@@@@     %@@    &@@@     @@@@@     &@@@
#   *@@@@@#      @@.   %@@@@    .@(       &@@@@        #@@@    /@@@@.    %@@     @@@@@*    (@@    @@@#     @@@@@#    .@@@
#/ @@@@@@@      @@@    &@@@@     @#       .@@@@        /@@#    (@@@.     @@*     @@@@@     ,@@    %@@@     @@@@@@     @@@
#@@@@@@@@      &@@@    %@@@@     @#        #@@#        ,@@#    ,@@(     @@@     /@@@@@.     @@    #@@@     &@@@@&     @@@
#@@@@@@@      #@@@,    #@@@@     &#        *@@*        .@@@           (@@@@     %@@@@@*     %@    *@@@     (@@@@      %@@
#@@@@@@&     *@@@@,    (@@@@/    @#   .     @%          @@#    (@@@     %@@     &@@@@@@     ,@.   /@@&     /@@@@      /@@
#@@@@@@      %@@@@,    /@@@@    ,@#   %@.        @#    .@@*    %@@@@,    #@     #@@@@@@     %@.   #@@@     (@@@@      ,@@
#@@@@@      *@@@@@@,   /@@@@    (@(   @@/       (@,    ,@@*    #@@@@/    ,@,    /@@@@@      @@    %@@@     @@@@@@     (@@
#@@@@      .@@@@@@@@   .@@@%    /@(   @@@       @@     *@@*    %@@@@     ,@*    ,@@@@@     ,@@    %@@@     @@@@@#     @@@
#@@@@      @@@@@@@( (    #/   .@@@,   (@@.     .@@.    (@@,    &@@@@     (@(    .@@@@@     #@@.   /@@@     @@@@@     #@@@
#@@@      %@@@@@@   /@@.    (@@@@@    .@@@     ,@@(    &@@,    %@@@      @@@    .@@@@@     &@&    .@@&.    @@@@@     @@@@
#@@      /@@@@@@    @@@@@@@@@@@@@@/   .@@@,    %@@     /@             (@@@@@@.   (@@@.     @@.     /@@    ,@@@@     @@@@@
#@      ,@@@@@@     @@@@@@@@@@@@@@    /@@@&   ,@@@     ,@@@@@@@@@@&@@@@@@@@@@@    ,@/    /@@@@@@@@@@@.      /     *@@@@@@
#@      @@@@@@      @@@@@@@@@@@@@      &@@@   @@@(      %@###%.,/###%@((    #@@@,      *@@@@@@@@@@@@@/ ,((,..*/%@@@@@@@@@
#                   &@@@@@@@@@@@@(,(#(*@@@@@@@@@@( ,//*,&@@                     /@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##(*,,. ..,,*****,*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&##                         .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         .%*/@@@( (%#/          /#&( &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     .#(   / .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# Please install pip on your system, install the dependencies that will be throwing errors when you launch the program and create a separate python virtual environmment (very easy to do) to launch this software.
# Oh, also remember to get a telegram bot TOKEN from the botfather bot and replace the TOKEN variable value with it. You will need to put the group chat id in SERVER_CHATS. To get your group chat id, add the bot to the group chat and use the command /id
# Also make sure your bot is in your public group with admin priviledges and disable the privacy setting of your bot from botfather chat using /setprivacy command or whatever it is.
# I think this should be it...

# PZserver TG Module - Copyright (C) 2023 Damiano Meda
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail.
# If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode:

# PZserver TG Module - Copyright (C) 2023 Damiano Meda
# This program comes with ABSOLUTELY NO WARRANTY; This is free software, and you are welcome to redistribute it under certain conditions. Contact me at damiano.meda@gmail.com for more info.

########################################
### FUNDAMENTAL CONSTANTS
########################################

if __name__ == '__main__':
    SERVER_CHATS=[] #Production
    #SERVER_CHATS = [] #Test
    TOKEN = ''
    SERVICE_NAME = 'pzserver'
    DEVS=['']

########################################################################################################################
### GET PATHS
########################################################################################################################

if __name__ == '__main__':
    import os
    FILENAME = os.path.basename(__file__)
    BASENAME = os.path.splitext(FILENAME)[0]
    FOLDER = os.path.abspath(os.path.dirname(__file__))

########################################################################################################################
### INFORMATION FOR THE LOG FILE
########################################################################################################################

def log_timestamp():
    from datetime import datetime
    return datetime.now().strftime('[%Y-%m-%d %H:%M:%S]')

def log_file():
    import os
    return os.path.join(os.path.abspath(os.path.dirname(__file__)), os.path.splitext(os.path.basename(__file__))[0]+'.log')

def logger(message, msg_type, log_file=log_file()):
    import os
    import traceback
    with open(log_file, 'a') as f:
        timestamp = log_timestamp()
        f.write(timestamp+" ["+msg_type+"] "+str(message)+'\n')
        traceback_str = traceback.format_exc()
        if msg_type == 'ERROR':
            if traceback_str:
                f.write(timestamp+"[TRACEBACK] "+traceback_str)

def log_emendazio(max_rows=1000, buffer=300, log_file=log_file()):
    try:
        with open(log_file, 'r') as f:
                lines = f.readlines()
                if len(lines) >= max_rows:
                    lines = lines[-(max_rows - buffer):]
                with open(log_file, 'w') as f:
                    f.writelines(lines)
    except Exception as e:
        logger(e, "ERROR")
        return None

########################################################################################################################
### USEFUL TOOLS
########################################################################################################################

def timestamp():
    from datetime import datetime
    return datetime.now()

def unix_timestamp():
    import time
    return int(time.time())

def unix_timestamp_to_log_timestamp(unix_timestamp):
    from datetime import datetime
    return datetime.utcfromtimestamp(unix_timestamp).strftime('[%Y-%m-%d %H:%M:%S]')
    
def run_command(command):
    import subprocess
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        output, error = process.communicate()
        if process.returncode != 0:
            logger(error, "OS ERROR")
            return None
        return output
    except Exception as e:
        logger(e, "ERROR")

def check_service_status(service_name=SERVICE_NAME):
    import subprocess
    try:
        if 'Active: active (running)' in run_command('systemctl status '+SERVICE_NAME).split('\n')[2]:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")
        return None

def strip_img_url_from_steam(workshop_url):
    try:
        img_url = run_command("curl -kl "+workshop_url+" | grep \"steamuserimages-a.akamaihd.net/ugc\" | egrep -v \"property|twitter\" | grep \"letterbox=true\" | head -1 | awk \'{print $2}\'").split("?")[0][1:]
        logger(f"A image url has been stripped from steam workshop: {img_url}", "INFO")
        return img_url
    except Exception as e:
        logger(e, "ERROR")

def is_workshop_url(url):
    try:
        import re
        pattern = r"https:\/\/steamcommunity\.com\/sharedfiles\/filedetails\/\?id=\d+"
        if re.match(pattern, url):
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def valid_steam_id(steam_id):
    try:
        if steam_id.isdigit() and len(steam_id) == 17:
            return int(steam_id)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def ensure_max_occurrences(array, value, N):
    try:
        count = 0
        index = 0
        while index < len(array):
            if array[index] == value:
                count += 1
                if count > N:
                    del array[index]
                    continue  # Continue without incrementing index
            index += 1
        return array
    except Exception as e:
        logger(e, "ERROR")

def format_time(seconds):
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    if hours > 0:
        return f"{int(hours)} h {int(minutes)} m {int(seconds)} s"
    elif minutes > 0:
        return f"{int(minutes)} m {int(seconds)} s"
    else:
        return f"{int(seconds)} s"

########################################################################################################################
### AVOID DOUBLE EXECUTION OF THIS SCRIPT ON THE CURRENT SYSTEM
########################################################################################################################

def get_pid_and_name():
    import os
    import sys
    try:
        return (os.getpid(), os.path.abspath(sys.argv[0]))
    except Exception as e:
        logger(e, "ERROR")

def is_already_running(current_pid, current_script):
    try:
        processes = run_command('ps aux | grep ' + current_script)
        if processes:
            lines = processes.split('\n')
            for line in lines:
                if current_script in line and 'python' in line:
                    pid = int(line.split()[1])
                    if pid != current_pid:
                        return True
        return False
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        pid, name = get_pid_and_name()
        if is_already_running(pid, name):
            print("Another instance of the script is already running.")
            import sys
            sys.exit(1)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### SERVER SETTINGS
########################################################################################################################

def process_serverini(line):
    try:
        if line.startswith("#"):
            return (1, line.strip()[2:])
        elif "=" in line:
            line = line.split("=")
            variable, value = line[0].strip(), line[1].strip()
            return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def process_sandbox_vars(line):
    try:
        if "=" in line:
            if "{" in line:
                return None
            elif "--" in line:
                return (1, line.strip()[3:])
            else:
                line = line.split("=")
                variable, value = line[0].strip(), line[1].strip()[:-1]
                return (0, (variable, value))
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    SERVERINI = ["servertest.ini", "/opt/pzserver/Zomboid/Server/servertest.ini", process_serverini]
    SANDBOXVARS = ["servertest_SandboxVars.lua", "/opt/pzserver/Zomboid/Server/servertest_SandboxVars.lua", process_sandbox_vars]

def get_settings():
    try:
        global SERVERINI
        global SANDBOXVARS
        setting_files = [SERVERINI, SANDBOXVARS]
        class Variable:
            def __init__(self, value, description, file_path, line_number):
                self.value = value
                self.description = description
                self.path = file_path
                self.line = line_number
        class Settings:
            pass
        settings = Settings()
        for basename, file_path, processor in setting_files:
            with open(file_path, 'r') as file:
                description = ""
                line_number=0
                for line in file:
                    processed = processor(line)
                    if processed:
                        is_description, data = processed[0], processed[1]
                        if is_description:
                            description += data + "\n"
                        else:
                            variable, value = data
                            setattr(settings, variable, Variable(value, description, file_path, line_number))
                            #print("section: "+basename); print(variable+": "+value); print(description); print(line_number); print("-------------------------")
                            description = ""
                    line_number += 1
        return settings
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    global_settings = get_settings()

########################################
### SETTINGS MANAGERS
########################################

def reload_settings():
    try:
        global global_settings
        global_settings = get_settings()
    except Exception as e:
        logger(e, "ERROR")

def setting_timestamp():
    try:
        pass
    except Exception as e:
        logger(e, "ERROR")

def save_setting_to_file(setting, value):
    try:
        file_path = getattr(global_settings, setting).path
        with open(file_path, 'r') as file:
            all_lines = file.readlines()
            line_number = getattr(global_settings, setting).line
            line = all_lines[line_number]
            if setting in line:
                all_lines[line_number] = line.replace(getattr(global_settings, setting).value, value)
                with open(file_path, 'w') as file:
                    file.writelines(all_lines)
                return True
            return False
    except Exception as e:
        logger(e, "ERROR")

def is_setting(setting):
    try:
        return hasattr(global_settings, setting)
    except Exception as e:
        logger(e, "ERROR")

def get_setting(setting):
    try:
        if hasattr(global_settings, setting):
            return getattr(global_settings, setting)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def set_setting_value(setting, value):
    try:
        if hasattr(global_settings, setting):
            if save_setting_to_file(setting, value):
                reload_settings()
                return True
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################
### MOD MANAGER & TOOLS
########################################

def is_modid(mod_id):
    try:
        return (char.isalnum() or char == '_' for char in mod_id)
    except Exception as e:
        logger(e, "ERROR")

def is_workshopid(workshop_id):
    try:
        return all(char.isdigit() for char in workshop_id) and len(workshop_id) == 10
    except Exception as e:
        logger(e, "ERROR")

def sort_valid_modid_workshopid(id1, id2):
    try:
        if is_workshopid(id1):
            if is_modid(id2):
                return[id2,id1]
            else:
                return False
        elif is_workshopid(id2):
            if is_modid(id1):
                return[id1,id2]
            else:
                return False
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def valid_modid_list(modid_list):
    try:
        if not modid_list:
            return True  # Empty string is allowed
        return all(is_modid(item) for item in modid_list)
    except Exception as e:
        logger(e, "ERROR")

def valid_workshopid_list(workshopid_list):
    try:
        if not workshopid_list:
            return True  # Empty string is allowed
        return all(is_workshopid(item) for item in workshopid_list)
    except Exception as e:
        logger(e, "ERROR")

def valid_modid_workshopid_list(modid_list, workshopid_list):
    try:
        return len(modid_list) == len(workshopid_list) and valid_modid_list(modid_list) and valid_workshopid_list(workshopid_list)
    except Exception as e:
        logger(e, "ERROR")

def get_mod_and_workshopid_list():
    try:
        modid_list = get_setting('Mods').value
        workshopid_list = get_setting('WorkshopItems').value
        if modid_list and workshopid_list:
            return ((modid_list.split(';'), workshopid_list.split(';')))
        else:
            return (([],[])) # No mods installed
    except Exception as e:
        logger(e, "ERROR")

def get_valid_modid_workshopid_list():
    try:
        modid_list, workshopid_list = get_mod_and_workshopid_list()
        if valid_modid_workshopid_list(modid_list, workshopid_list):
            return (modid_list, workshopid_list)
        else:
            logger("Sanity check failing for mod lists.", "WARNING")
            return False
    except Exception as e:
        logger(e, "ERROR")

def get_workshopid_from_installed_mods(modid):
    try:
        valid_mod_lists = get_valid_modid_workshopid_list()
        if valid_mod_lists:
            modid_list, workshopid_list = valid_mod_lists
            if is_modid(modid):
                if modid in modid_list:
                    return workshopid_list[modid_list.index(modid)]
                else:
                    return False
            else:
                return None
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None

def strip_IDs_from_steam(url):
    try:
        import requests
        import re
        response = requests.get(url)
        if response.status_code == 200:
            source_code = response.text
            match = re.search(r"Mod ID:\s*([a-zA-Z0-9_()]+)", source_code)
            if match:
                mod_id = match.group(1)
                return sort_valid_modid_workshopid(mod_id, url.split('=')[1])
            return False
        else:
            logger(f"Failed to fetch page. Status code: {str(response.status_code)}", "ERROR")
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None
            
def mod_is_installed(id1, id2):
    try:
        valid = sort_valid_modid_workshopid(id1, id2)
        if valid:
            modid, workshopid = valid
            valid = get_valid_modid_workshopid_list()
            if valid:
                mod_list, workshop_list = valid
                if modid not in mod_list and workshopid not in workshop_list:
                    return False
                elif modid in mod_list:
                    if workshopid in workshop_list:
                        if mod_list.index(modid) == workshop_list.index(workshopid):
                            return True
                        else:
                            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") resulted installed but are not at the same position in config file. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING") #This case might be a hint for issues in loading mods in game
                            return None
                    elif workshopid not in workshop_list:
                        logger(f"{modid} is in the list but {workshopid} isn't. Weird, since a workshopid can have multiple modid but not viceversa. If mods are being loaded correctly, you can safely ignore this warning.", "WARNING") #This case might be a hint for issues in loading mods in game
                        return None
                else:
                    logger(f"{modid} is not in the list but {workshopid} is. It could be a portion of the same mod with a different name.", "INFO", log_file()) #This case might be a hint for issues in loading mods in game
                    return False
            else:
                return valid
        else:
            logger("Mod IDs entered in chat ("+modid+", "+workshopid+") are invalid. Are you having fun or what?", "WARNING", log_file())
            return None
    except Exception as e:
        logger(e, "ERROR")
        return None

def install_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modids=get_setting(modid_setting).value
        workshopids=get_setting(workshopid_setting).value
        set_setting_value(modid_setting, modids+";"+modid)
        set_setting_value(workshopid_setting, workshopids+";"+workshopid)
    except Exception as e:
        logger(e, "ERROR")

def uninstall_mod(modid, workshopid, modid_setting='Mods', workshopid_setting='WorkshopItems'):
    try:
        modid_list, workshopid_list = get_valid_modid_workshopid_list()
        position = modid_list.index(modid)
        modid_list.pop(position)
        workshopid_list.pop(position)
        modid_list_text = ';'.join(map(str, modid_list))
        workshopid_list_text = ';'.join(map(str, workshopid_list))
        set_setting_value('Mods', modid_list_text)
        set_setting_value('WorkshopItems', workshopid_list_text)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### DATABASES PLAYGROUND
########################################################################################################################

if __name__ == '__main__':
    import os
    reforms_db = os.path.join(FOLDER, 'reforms.db')
    players_db = os.path.join(FOLDER,'players.db')
    sessions_db = os.path.join(FOLDER,'sessions.db')

# TO CREATE SETTINGS BACKUPS
def selfcreate_sqlite_table(table_name, **kwargs):
    import sqlite3
    import os
    try:
        if len(kwargs) < 1:
            return
        db_file = f"{table_name}.db"
        db_path = os.path.join(FOLDER, db_file)
        conn = sqlite3.connect(db_path)
        c = conn.cursor()
        pk = list(kwargs.keys())[0]
        columns = []
        for key, value in kwargs.items():
            valid_types = [int, float, str]
            if type(value) not in valid_types:
                return False
            sqlite_type = {int: "INTEGER", float: "REAL", str: "TEXT"}[type(value)]
            if key == pk:
                columns.append(f"{key} {sqlite_type} PRIMARY KEY")
            else:
                columns.append(f"{key} {sqlite_type}")
        if len(columns) < 1:
            return False
        create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(columns)})"
        c.execute(create_table_sql)
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Reform:
    def __init__(self, reform_id=None, reform_chat_id=None, reform_name=None, reform_description=None, reform_date=None, reform_implemented=None, reform_is_active = None,
                poll_id=None, poll_message_id=None, poll_options=None,poll_consensus_coefficient=None, poll_stop_date=None, poll_yes_list="", poll_no_list="",
                change_ctype=None, change_mod_action=None, change_mod_modid=None, change_mod_workshopid=None, change_setting_variable=None, change_setting_old_value=None, change_setting_new_value=None,
                proposer_first_name=None, proposer_last_name=None, proposer_username=None, proposer_id=None):
        self.reform_id = reform_id
        self.reform_chat_id = reform_chat_id
        self.reform_name = reform_name
        self.reform_description = reform_description
        self.reform_date = reform_date
        self.reform_implemented = reform_implemented
        self.reform_is_active = reform_is_active
        self.poll_id = poll_id
        self.poll_message_id = poll_message_id
        self.poll_options = poll_options
        self.poll_consensus_coefficient = poll_consensus_coefficient
        self.poll_stop_date = poll_stop_date
        self.poll_yes_list = poll_yes_list
        self.poll_no_list = poll_no_list
        self.change_ctype = change_ctype
        self.change_mod_action = change_mod_action
        self.change_mod_modid = change_mod_modid
        self.change_mod_workshopid = change_mod_workshopid
        self.change_setting_variable = change_setting_variable
        self.change_setting_old_value = change_setting_old_value
        self.change_setting_new_value = change_setting_new_value
        self.proposer_first_name = proposer_first_name
        self.proposer_last_name = proposer_last_name
        self.proposer_username = proposer_username
        self.proposer_id = proposer_id
    
    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_reform_table():
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS reforms (
        reform_id INTEGER PRIMARY KEY,
        reform_chat_id INTEGER,
        reform_name TEXT,
        reform_description TEXT,
        reform_date INTEGER,
        reform_implemented INTEGER,
        reform_is_active INTEGER,
        poll_id INTEGER,
        poll_message_id INTEGER,
        poll_options INTEGER,
        poll_consensus_coefficient REAL,
        poll_stop_date INTEGER,
        poll_yes_list TEXT,
        poll_no_list TEXT,
        change_ctype TEXT,
        change_mod_action TEXT,
        change_mod_modid TEXT,
        change_mod_workshopid TEXT,
        change_setting_variable TEXT,
        change_setting_old_value TEXT,
        change_setting_new_value TEXT,
        proposer_first_name TEXT,
        proposer_last_name TEXT,
        proposer_username TEXT,
        proposer_id INTEGER)''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Player:
    def __init__(self, steam_id, telegram_id, username, access, visit_count, last_seen, total_time, average_session, voted_yes, voted_no, proposed_change, got_change_accepted, got_change_rejected):
        self.steam_id = steam_id
        self.telegram_id = telegram_id
        self.username = username
        self.access = access
        self.visit_count = visit_count
        self.last_seen = last_seen
        self.total_time = total_time
        self.average_session = average_session
        self.voted_yes = voted_yes
        self.voted_no = voted_no
        self.proposed_change = proposed_change
        self.got_change_accepted = got_change_accepted
        self.got_change_rejected = got_change_rejected

    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_players_table():
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS players (
        steam_id INTEGER PRIMARY KEY,
        telegram_id INTEGER,
        usernames TEXT,
        first_time_seen_on INTEGER,
        access TEXT)''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

class Session:
    def __init__(self, session_id=None, steam_id=None, login=None, logout=None, ip=None):
        self.session_id = session_id
        self.steam_id = steam_id
        self.login = login
        self.logout = logout
        self.ip = ip

    def print_all(self):
        for var_name, var_value in vars(self).items():
            print(f"{var_name}: {var_value}")

def init_sessions_table():
    try:
        import sqlite3
        conn = sqlite3.connect(sessions_db)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS sessions (
        session_id INTEGER PRIMARY KEY,
        steam_id INTEGER,
        login INTEGER,
        logout INTEGER,
        ip TEXT)''')
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

if __name__ == '__main__':
    try:
        init_reform_table()
        init_players_table()
        init_sessions_table()
    except Exception as e:
        logger(e, "ERROR")

########################################
### DB FUNCTIONS
########################################

def save_reform(reform):
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        # Check if the reform already exists in the table
        c.execute('SELECT * FROM reforms WHERE reform_id = ?', (reform.reform_id,))
        existing_reform = c.fetchone()
        if existing_reform:
            # Reform exists, update it
            update_columns = ', '.join([f"{col} = ?" for col in reform.__dict__.keys()])
            update_values = tuple(reform.__dict__.values()) + (reform.reform_id,)  # Include reform_id for WHERE clause
            c.execute(f'UPDATE reforms SET {update_columns} WHERE reform_id = ?', update_values)
        else:
            # Reform does not exist, insert it
            columns = ', '.join([col for col in reform.__dict__.keys()])
            placeholders = ', '.join(['?' for _ in range(len(reform.__dict__))])
            values = tuple(reform.__dict__.values())
            c.execute(f'INSERT INTO reforms ({columns}) VALUES ({placeholders})', values)
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def get_player(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute('SELECT * FROM players WHERE steam_id = ?', (steam_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Player(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_reform(reform_id):
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE reform_id = ?', (reform_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_reform_by_poll_id(poll_id):
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE poll_id = ?', (poll_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return None
    except Exception as e:
        logger(e, "ERROR")

def get_mod_clone_change(modid, workshopid, action):
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE change_mod_modid = ? AND change_mod_workshopid = ? AND change_mod_action = ? AND reform_is_active = ?', (modid, workshopid, action, 1))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def get_setting_clone_change(variable, new_value):
    try:
        import sqlite3
        conn = sqlite3.connect(reforms_db)
        c = conn.cursor()
        c.execute('SELECT * FROM reforms WHERE change_setting_variable = ? AND change_setting_new_value = ? AND reform_is_active = ?', (variable, new_value, 1))
        result = c.fetchone()
        conn.close()
        if result:
            return Reform(*result)
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def player_set_telegram_id(steam_id, telegram_id):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute("SELECT * FROM players WHERE steam_id = ?", (steam_id,))
        existing_player = c.fetchone()
        if existing_player:
            c.execute("UPDATE players SET telegram_id = ? WHERE steam_id = ?", (telegram_id, steam_id))
            conn.commit()
            conn.close()
            return True
        conn.commit()
        conn.close()
        return False
    except Exception as e:
        logger(e, "ERROR")

def player_get_telegram_id(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute('SELECT telegram_id FROM players WHERE steam_id = ?', (steam_id,))
        result = c.fetchone()
        conn.close()
        if result:
            return result[0]
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

def user_is_registered(telegram_id):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute("SELECT steam_id FROM players WHERE telegram_id=?", (telegram_id,))
        steam_id = c.fetchone()
        conn.close()
        return steam_id[0] if steam_id else False
    except Exception as e:
        logger(e, "ERROR")

def  player_is_registered(steam_id):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute("SELECT telegram_id FROM players WHERE steam_id=?", (steam_id,))
        telegram_id = c.fetchone()
        conn.close()
        return telegram_id[0] if telegram_id else False
    except Exception as e:
        logger(e, "ERROR")

def session_open(steam_id, login, ip):
    try:
        import sqlite3
        conn = sqlite3.connect(sessions_db)
        c = conn.cursor()
        c.execute("INSERT INTO sessions (steam_id, login, ip) VALUES (?, ?, ?)", (steam_id, login, ip))
        session_id = c.lastrowid
        conn.commit()
        conn.close()
        return session_id
    except Exception as e:
        logger(e, "ERROR")

def session_close(session_id, logout):
    try:
        import sqlite3
        conn = sqlite3.connect(sessions_db)
        c = conn.cursor()
        c.execute("UPDATE sessions SET logout = ? WHERE session_id = ?", (logout, session_id))
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        logger(e, "ERROR")

def upsert_player(steam_id, username, access):
    try:
        import sqlite3
        conn = sqlite3.connect(players_db)
        c = conn.cursor()
        c.execute("SELECT * FROM players WHERE steam_id = ?", (steam_id,))
        existing_player = c.fetchone()
        if existing_player:
            c.execute('SELECT usernames FROM players WHERE steam_id = ?', (steam_id,))
            usernames = c.fetchone()[0].split(',')
            if username not in usernames:
                usernames.append(username)
                c.execute("UPDATE players SET usernames = ?, access = ? WHERE steam_id = ?", (','.join(map(str, usernames)), access, int(steam_id)))
        else:
            c.execute("INSERT INTO players (steam_id, usernames, access, first_time_seen_on) VALUES (?, ?, ?, ?)", (int(steam_id), username, access, unix_timestamp()))
        conn.commit()
        conn.close()
    except Exception as e:
        logger(e, "ERROR")

def get_player_stats(telegram_id):
    pass

def get_user_activity_info(telegram_id):
    try:
        import sqlite3
        conn_players = sqlite3.connect(players_db)
        c_players = conn_players.cursor()

        # Get steam_id associated with the provided telegram_id
        c_players.execute("SELECT steam_id, first_time_seen_on FROM players WHERE telegram_id=?", (telegram_id,))
        steam_id, first_time_seen_on = c_players.fetchone()

        # Get count of logins, total time connected, and average session duration
        c_sessions = sqlite3.connect(sessions_db).cursor()
        c_sessions.execute("SELECT COUNT(*), SUM(logout - login), AVG(logout - login) FROM sessions WHERE steam_id=?", (steam_id,))
        login_count, total_time_connected, avg_session_duration = c_sessions.fetchone()

        # Calculate activity coefficient for the last 7 days
        # This requires additional calculations

        # Get the number of reforms proposed by the user
        c_reforms = sqlite3.connect(reforms_db).cursor()
        c_reforms.execute("SELECT COUNT(*) FROM reforms WHERE proposer_id=?", (telegram_id,))
        proposed_reforms_count = c_reforms.fetchone()[0]

        # Get the number of proposed reforms that got implemented
        c_reforms.execute("SELECT COUNT(*) FROM reforms WHERE proposer_id=? AND reform_implemented=1", (telegram_id,))
        implemented_reforms_count = c_reforms.fetchone()[0]

        # Get the number of times the user voted yes, no, and didn't vote
        c_reforms.execute("SELECT poll_yes_list, poll_no_list, reform_date FROM reforms")
        reforms_data = c_reforms.fetchall()

        voted_yes_count = 0
        voted_no_count = 0
        did_not_vote_count = 0
        poll_count = 0

        for poll_yes_list, poll_no_list, reform_date in reforms_data:
            # Check if the user could have possibly voted based on their join date
            if first_time_seen_on <= reform_date:
                poll_yes_list = poll_yes_list.split(",") if poll_yes_list else []
                poll_no_list = poll_no_list.split(",") if poll_no_list else []
                poll_count += 1
                # Check if user's telegram_id is in yes list
                if str(telegram_id) in poll_yes_list:
                    voted_yes_count += 1
                # Check if user's telegram_id is in no list
                elif str(telegram_id) in poll_no_list:
                    voted_no_count += 1
                else:
                    did_not_vote_count += 1

        # Close connections
        conn_players.close()
        c_sessions.close()
        c_reforms.close()

        voted_yes_perc = (voted_yes_count / poll_count * 100) if poll_count != 0 else 0
        voted_no_perc = (voted_no_count / poll_count * 100) if poll_count != 0 else 0
        did_not_vote_perc = (did_not_vote_count / poll_count * 100) if poll_count != 0 else 0

        return f'''Login count: {login_count}
Total time played: {format_time(total_time_connected)}
Average session: {format_time(avg_session_duration)}

Reforms proposed: {proposed_reforms_count}  [ {implemented_reforms_count} âœ“ ]

Out of {poll_count} polls, you voted:
Yes: {voted_yes_count} ({voted_yes_perc}%) - No: {voted_no_count} ({voted_no_perc}%) - Blank: {did_not_vote_count} ({did_not_vote_perc}%)'''

    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### COMMAND SETUP & COMMAND RELATED
########################################################################################################################

### COMMANDS - FUNCTIONS

def add_cmd(command_list, cmd, description):
    try:
        from telebot import types
        #print("CMD: "+cmd+" ("+str(len(cmd))+")")
        #print("DESC: "+description+" ("+str(len(description))+")\n")
        command_list.append(types.BotCommand(command=str(cmd), description=str(description)))
        return True
    except Exception as e:
        logger(e, "ERROR")

def add_cmd_bulk(command_list, cmd_list):
    try:
        from telebot import types
        for cmd, description in cmd_list:
            add_cmd(command_list, cmd, description)
        return command_list
    except Exception as e:
        logger(e, "ERROR")

def init_commands():
    try:
        command_list = []
        return add_cmd_bulk(command_list, [[start_cmd,start_desc],[restart_cmd,restart_desc],[status_cmd,status_desc],[stats_cmd,stats_desc],[mod_cmd,mod_desc],[setting_cmd,setting_desc],[register_cmd,register_desc],[help_cmd,help_desc]])
    except Exception as e:
        logger(e, "ERROR")

### COMMAND - MESSAGES

if __name__ == '__main__':
    start_cmd='start'
    start_desc='Display bot welcome message.'
    start_msg='Hi, I am Rotting Ghoul! I can automatically get you updates on the status of the PZserver.'
    status_cmd='status'
    status_desc='Retrive the current status of '+SERVICE_NAME
    restart_cmd='restart'
    restart_confirm_cmd='confirm_restart'
    restart_cancel_cmd='cancel_restart'
    restart_desc='Restart the application'
    restart_msg="Are you really sure you want to restart the server? All users will be disconnected.\n\nPlease press: /"+restart_confirm_cmd+" to proceed.\n\nOr press: /"+restart_cancel_cmd+" to cancel."
    stats_cmd='stats'
    stats_desc='Display account stats of a registered account'
    stats_msg_helper='To see your stats use /'+stats_cmd+''' or:
        /'''+stats_cmd+''' <steam id>  [for another player]'''
    mod_cmd='mod'
    mod_desc='Manage installed mods through polls'
    mod_msg_helper='''To use '''+mod_cmd+''' command please use:
        /'''+mod_cmd+''' list
        /'''+mod_cmd+''' install <Mod URL>
        /'''+mod_cmd+''' install <Mod ID> <Workshop ID>
        /'''+mod_cmd+''' uninstall <Mod URL>
        /'''+mod_cmd+''' uninstall <Mod ID>
        /'''+mod_cmd+''' uninstall <Mod ID> <Workshop ID>'''
    setting_cmd='setting'
    setting_desc='Manage server settings through polls'
    setting_msg_helper='''To use '''+setting_cmd+''' command please use:
        /'''+setting_cmd+''' get <parameter>
        /'''+setting_cmd+''' set <parameter> <value>'''
    register_cmd='register'
    register_desc='Link the game account with your telegram account'
    register_msg_helper='''To link your game account and use /'''+stats_cmd+''' please use:
        /'''+register_cmd+''' <your steam id>
        
How to find your steam ID:
https://help.steampowered.com/en/faqs/view/2816-BE67-5B69-0FEC'''
    help_cmd='help'
    help_desc='Provide the command legenda.'
    help_msg='List of the commands:\n/'+help_cmd+': '+help_desc+'''
/'''+restart_cmd+': '+restart_desc+'''
/'''+status_cmd+': '+status_desc+'\n'+mod_msg_helper+'\n'+setting_msg_helper+'\n'+stats_msg_helper+'\n'+register_msg_helper

    ### OTHER MESSAGES

    strip_modid_from_url_failed = "Getting modID from steam URL failed. Try using legacy syntax."
    not_a_workshop_url = "The URL you provided has not been recognized as a valid workshop URL. Try the legacy syntax maybe?"
    already_installed_msg = "The mod you want to install is already installed."
    msg_mod_not_installed = "The mod you want to uninstall is not installed"
    msg_modid_invalid = "The mod ID entered are being considered invalid."
    msg_no_mods_installed = "There are no mods installed."
    msg_unhandled_exception = "Unhandled exception, check logs, call the police or contact the administrator."
    msg_workshopid_from_file_failed = "Getting the workshop ID from the config file failed. Check logs."
    
### COMMANDS - RESTART DOUBLE CHECK - no database, just memory

global_restart_requests = []

def save_restart(restart_cmd, user):
    try:
        global global_restart_requests
        for each in global_restart_requests:
            if each[1] == user:
                each[0] = cmd
                return
        global_restart_requests.append((cmd, user))        
    except Exception as e:
        logger(e, "ERROR")

def check_restart(restart_cmd, user):
    try:
        global global_restart_requests
        for each in global_restart_requests:
            if each[0] == cmd and each[1] == user:
                return True
        return False
    except Exception as e:
        logger(e, "ERROR")

def clear_restart(user):
    try:
        global global_restart_requests
        temp = global_restart_requests
        for each in global_restart_requests:
            if each[1] == user:
                temp.remove(each)
                removed = True
        global_restart_requests = temp
        print(global_restart_requests)
        if removed:
            return True
        else:
            return False
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### INITIALIZE BOT
########################################################################################################################

if __name__ == '__main__':
    try:
        import telebot
        bot = telebot.TeleBot(TOKEN)
        commands = init_commands()
        if commands:
            bot.set_my_commands(commands)
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### BOT RELATED USEFUL TOOLS
########################################################################################################################

def server_chat_message(text, disable_notification=True, disable_web_page_preview=False):
    for each in SERVER_CHATS:
        bot.send_message(each, text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview)

def reply_to(message, text, disable_notification=True, disable_web_page_preview=False):
    bot.reply_to(message, text, disable_notification=disable_notification, disable_web_page_preview=disable_web_page_preview)

def member_is_admin(message):
    member = bot.get_chat_member(message.chat.id, message.from_user.id)
    if member.status in ['creator','administrator']:
        return True
    else:
        reply_to(message, "This command requires administrator-level or superior priviledges.", disable_notification=True)
        return False

########################################################################################################################
### GAME RUNTIME LOG PARSING MANAGER
########################################################################################################################

### PARSING FLAGS & CONSTANTS

if __name__ == '__main__':
    PZSERVER_LOG = '/opt/pzserver/pzserver.log'

    open_sessions = []
    
    command_flag = True
    join_flag = True
    left_flag = True

    log_key_client_re_pattern = r'ip=([\d.]+).*?steam-id=(\d+) access=(\w+) username="([^"]+)"'

    log_key_start = 'Zomboid Server is VAC Secure'
    log_key_stop = 'command entered via server console (System.in): "quit"'
    log_key_client_init=['[receive-packet] "client-connect"','steam-id','username']
    log_key_client_connecting=['[receive-packet] "login-queue-request"','steam-id','username']
    log_key_client_connected=['[receive-packet] "login-queue-done"','steam-id','username']
    log_key_player_connected=['receive-packet] "player-connect"','steam-id','username']
    log_key_player_in_game=['[fully-connected]','steam-id','username']
    log_key_client_logout = ['[disconnect]','steam-id','username']
    log_key_cmd = 'command entered'
    log_key_death='replacing dead player'

### PARSING FUNCTIONS

def player_client_login_event(steam_id, username, access, ip):
    try:
        global open_sessions
        server_chat_message(f"A player connected to the server: {username}")
        upsert_player(steam_id, username, access)
        session = Session()
        session.steam_id = steam_id
        session.login = unix_timestamp()
        session.ip = ip
        session.id = session_open(steam_id, session.login, ip)
        session.print_all
        open_sessions.append(session)
    except Exception as e:
        logger(e, "ERROR")
        
def player_client_logout_event(steam_id, username, access, ip):
    try:
        global open_sessions
        server_chat_message(f"A player disconnected from the server: {username}")
        upsert_player(steam_id, username, access)
        if open_sessions:
            for session in open_sessions:
                if session.steam_id == steam_id:
                    session.logout = unix_timestamp()
                    session_close(session.id, session.logout)
                    open_sessions.pop(open_sessions.index(session))
                    if ip != session.ip:
                        logger(f"How can the logout IP ({ip}) of {username}[{steam_id}] be different from the login IP ({session.ip})", "WTF")
        else:
            logger("No open sessions, yet a player logged out.", "ERROR")
    except Exception as e:
        logger(e, "ERROR")

def alert_bot(keyword, line):
    try:
        import re
        if keyword == log_key_start:
            server_chat_message(SERVICE_NAME.capitalize()+" is now online.")
            #if not changes_are_applied():
            #    server_chat_message("Seems like some changes were not applied since last reboot. Check logs for more info.")
        elif keyword == log_key_stop:
            server_chat_message(SERVICE_NAME.capitalize()+" is going down...")
        elif command_flag and keyword == log_key_cmd:
            if '"quit"' not in line and '"save"' not in line:
                server_chat_message("A"+line[44:])
        elif join_flag and keyword == log_key_client_init:
            match = re.search(log_key_client_re_pattern, line)
            if match:
                ip = match.group(1)
                steam_id = int(match.group(2))
                access = match.group(3)
                username = match.group(4)
                player_client_login_event(steam_id, username, access, ip)
        elif left_flag and keyword == log_key_client_logout:
            match = re.search(log_key_client_re_pattern, line)
            if match:
                ip = match.group(1)
                steam_id = int(match.group(2))
                access = match.group(3)
                username = match.group(4)
                player_client_logout_event(steam_id, username, access, ip)
    except Exception as e:
        logger(e, "ERROR")

def monitor_log(filename=PZSERVER_LOG, keywords=[log_key_start, log_key_stop, log_key_client_init, log_key_client_logout, log_key_cmd]):
    try:
        import time
        with open(filename, 'r') as f:
            f.seek(0, 2)
            while True:
                current_position = f.tell()
                line = f.readline()
                if not line:
                    time.sleep(0.1)
                    f.seek(current_position)
                else:
                    for keyword in keywords: 
                        if type(keyword)==str:
                            if keyword in line:
                                alert_bot(keyword, line)
                        elif type(keyword)==list:
                            if all(key_fragment in line for key_fragment in keyword):
                                alert_bot(keyword, line)
    except Exception as e:
        logger(e, "ERROR")

### START PARSING
if __name__ == '__main__':
    try:
        import threading
        poll_monitor_log_thread = threading.Thread(target=monitor_log)
        poll_monitor_log_thread.start()
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### POLLING MANAGER & MONITOR
########################################################################################################################

def fake_poll_message(reform):
    try:
        class fakemessage:
            def __init__(self, chat_id, message_id):
                self.chat_id = chat_id
                self.message_id = message_id
            @property
            def chat(self):
                return fakechat(self.chat_id)
            @property
            def id(self):
                return self.message_id
        class fakechat:
            def __init__(self, chat_id):
                self.chat_id = chat_id
            @property
            def id(self):
                return self.chat_id
        # Eat your broccoli, bitch
        return fakemessage(chat_id=reform.reform_chat_id, message_id=reform.poll_message_id)
    except Exception as e:
        logger(e, "ERROR")

def create_poll(chat_id, description, options, anonymous=False, multiple_answers=False):
    try:
        poll = bot.send_poll(chat_id, question=description, options=options, is_anonymous=anonymous, allows_multiple_answers=multiple_answers)
        return poll
    except Exception as e:
        logger(e, "ERROR")

def stop_poll(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        reform.poll_stop_date = unix_timestamp()
        save_reform(reform)
        return bot.stop_poll(reform.reform_chat_id, reform.poll_message_id)
    except Exception as e:
        logger(e, "ERROR")

def deny_change(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        reform.reform_is_active = 0
        reform.reform_implemented = 0
        save_reform(reform)
        #reform.print_all()
        reply_to(fake_poll_message(reform), "This change has been rejected.")
    except Exception as e:
        logger(e, "ERROR")

def implement_change(reform=None, poll_id=None):
    try:
        if not reform:
            reform = get_reform_by_poll_id(poll_id)
        if reform.change_ctype == 'mod':
            if reform.change_mod_action == 'install':
                install_mod(reform.change_mod_modid, reform.change_mod_workshopid)
            elif reform.change_mod_action == 'uninstall':
                uninstall_mod(reform.change_mod_modid, reform.change_mod_workshopid)
            logger(f"Type: {reform.change_ctype} Action: {reform.change_mod_action} ModID: {reform.change_mod_modid} WorkshopID: {reform.change_mod_workshopid} Date: {log_timestamp}", "INFO")
        elif reform.change_ctype == 'setting':
            logger(f"Type: {reform.change_ctype} Variable: {reform.change_setting_variable} Old Value: {reform.change_setting_old_value} Current Value: {get_setting(reform.change_setting_variable).value} New Value: {reform.change_setting_new_value} Date: {log_timestamp}", "INFO")
            set_setting_value(reform.change_setting_variable, reform.change_setting_new_value)
        reform.reform_is_active = 0
        reform.reform_implemented = 1
        save_reform(reform)
        #reform.print_all()
        reply_to(fake_poll_message(reform), "This change has been implemented.")
    except Exception as e:
        logger(e, "ERROR")

def consensus(reform=None, poll_id=None, votes_from = 'db', consensus = False, virdict = None):
    try:
        if votes_from == 'db':
            if not reform:
                reform = get_reform_by_poll_id(poll_id)
        max_voters = bot.get_chat_members_count(reform.reform_chat_id) - 1 # At least one bot (this one) is in the count, so we detract one.
        if reform.poll_options == 2:
            consensus_threshold = max_voters // reform.poll_options + 1 # Majority threshold (for testing remove the +1 and be alone in a group with just the bot)
        if votes_from == 'db':
                if reform.poll_yes_list:
                    yes_votes = len(reform.poll_yes_list.split(','))
                else:
                    yes_votes = 0
                if reform.poll_no_list:
                    no_votes = len(reform.poll_no_list.split(','))
                else:
                    no_votes = 0
                if yes_votes >= consensus_threshold:
                    consensus, virdict = (True, True)
                    reform.poll_consensus_coefficient = yes_votes / consensus_threshold
                elif no_votes >= consensus_threshold:
                    consensus, virdict = (True, False)
                    reform.poll_consensus_coefficient = no_votes / consensus_threshold
        elif votes_from == 'tg':
            pass
        if consensus:
            if virdict:
                implement_change(reform)
            else:
                deny_change(reform)
            stop_poll(reform)
            return (consensus, virdict)
        else:
            return (consensus, virdict)
        save_reform(reform)
    except Exception as e:
        logger(e, "ERROR")
        
def update_poll_vote(voter, poll_id, votes):
    try:
        reform = get_reform_by_poll_id(poll_id)
        #reform.print_all()
        if reform.poll_options == 2:
            yes_option_n = 0
            no_option_n = 1
            voter = str(voter)
            is_yes_list = False
            is_no_list = False
            if len(votes) > 0:
                if votes[0] == yes_option_n:
                    is_yes_list = True
                    if reform.poll_yes_list == "":
                        reform.poll_yes_list = voter
                    else:
                        reform.poll_yes_list = ','.join(map(str, ensure_max_occurrences(reform.poll_yes_list.split(',').append(voter), voter, 1)))
                elif votes[0] == no_option_n:
                    is_no_list = True
                    if reform.poll_no_list == "":
                        reform.poll_no_list = voter
                    else:
                        reform.poll_no_list = ','.join(map(str, ensure_max_occurrences(reform.poll_no_list.split(',').append(voter), voter, 1)))
            else: # retract_vote_option
                if reform.poll_yes_list:
                    vote_list = reform.poll_yes_list.split(',')
                    reform.poll_yes_list = ','.join(map(str, ensure_max_occurrences(vote_list, voter, 0)))
                if reform.poll_no_list:
                    vote_list = reform.poll_no_list.split(',')
                    reform.poll_no_list = ','.join(map(str, ensure_max_occurrences(vote_list, voter, 0)))
            #reform.print_all()
            save_reform(reform)
            consensus(reform)
    except Exception as e:
        logger(e, "ERROR")

def active_clone_changes(ctype, change):
    try:
        if ctype == 'mod':
            action, modid, workshopid = change
            return get_mod_clone_change(modid, workshopid, action)
        elif ctype == 'setting':
            variable, value = change
            return get_setting_clone_change(variable, value)
    except Exception as e:
        logger(e, "ERROR")

def mod_poll_launch(new_reform):
    try:
        poll = create_poll(new_reform.reform_chat_id, new_reform.reform_name, ['Yes','No'])
        workshop_url = f"https://steamcommunity.com/sharedfiles/filedetails/?id={new_reform.change_mod_workshopid}"
        get_steam_image_url = strip_img_url_from_steam(workshop_url) 
        reply_to(poll, workshop_url)
        bot.send_photo(new_reform.reform_chat_id, get_steam_image_url)
        return poll
    except Exception as e:
        logger(e, "ERROR")

def setting_poll_launch(new_reform):
    try:
        return create_poll(new_reform.reform_chat_id, new_reform.reform_name, ['Yes','No'])
    except Exception as e:
        logger(e, "ERROR")

def create_reform(message, ctype, change):
    try:
        clone = active_clone_changes(ctype, change)
        if not clone:
            import os
            new_reform = Reform()
            new_reform.reform_id = message.id
            new_reform.reform_chat_id = message.chat.id
            new_reform.reform_description = "" # FUTURE IMPLEMENTATION
            new_reform.reform_date = unix_timestamp()
            new_reform.reform_implemented = 0
            new_reform.reform_is_active = 1
            new_reform.proposer_first_name = message.from_user.first_name
            new_reform.proposer_last_name = message.from_user.last_name
            new_reform.proposer_username = message.from_user.username
            new_reform.proposer_id = message.from_user.id
            new_reform.change_ctype = ctype
            if ctype == 'mod':
                action, modid, workshopid = change
                new_reform.change_mod_action = action
                new_reform.change_mod_modid = modid
                new_reform.change_mod_workshopid = workshopid
                new_reform.reform_name = f"Do you want to {action} {modid}?"
                poll = mod_poll_launch(new_reform)
            elif ctype == 'setting':
                variable, value = change
                print(change)
                print(variable)
                print(value)
                new_reform.change_setting_variable = variable
                new_reform.change_setting_old_value = get_setting(variable).value
                new_reform.change_setting_new_value = value
                new_reform.reform_name = f"Set {variable} = {value}"
                poll = setting_poll_launch(new_reform)
            new_reform.poll_id = poll.poll.id
            new_reform.poll_message_id = poll.message_id
            new_reform.poll_options = len(poll.poll.options)
            #new_reform.print_all()
            save_reform(new_reform)
        else:
            reply_to(fake_poll_message(clone), "This change has been already proposed and is under trial process.")
    except Exception as e:
        logger(e, "ERROR")

########################################################################################################################
### MAIN - COMMAND HANDLERS
########################################################################################################################

if __name__ == '__main__':
    try:
        # SHOW CHAT ID
        @bot.message_handler(commands=['id'])
        def id_command(message):
            print(f"CHAT ID: {message.chat.id}")
            reply_to(message, f"CHAT ID: {message.chat.id}")
        # START
        @bot.message_handler(commands=[start_cmd])
        def start_command(message):
            reply_to(message, start_msg)
        # HELP
        @bot.message_handler(commands=[help_cmd])
        def help_command(message):
            reply_to(message, help_msg, disable_web_page_preview=True)
        # STATUS
        @bot.message_handler(commands=[status_cmd])
        def status_command(message):
            service_status = check_service_status()
            if service_status:
                status = "active."
            elif not service_status:
                status = "down."
            else:
                status = "???"
            reply_to(message, "The PZserver is currently "+status)
        # STATS
        @bot.message_handler(commands=[stats_cmd])
        def stats_command(message):
            command = message.text.split()
            if len(command) == 1:
                if user_is_registered(message.from_user.id):
                    reply_to(message, get_user_activity_info(message.from_user.id))
                else:
                    reply_to(message, "You need to register yourself if you want to see your stats.")
                    reply_to(message, register_msg_helper)
            elif len(command) == 2:
                steam_id = valid_steam_id(command[1])
                if steam_id:
                    telegram_id = player_is_registered(steam_id)
                    if telegram_id:
                        reply_to(message, get_user_activity_info(telegram_id))
                    else:
                        reply_to(message, "This user is not registered yet.")
                else:
                    reply_to(message, f"This is not a valid steam ID.")
            else:
                reply_to(message, stats_msg_helper, disable_web_page_preview=True)
        # REGISTER
        @bot.message_handler(commands=[register_cmd])
        def register_command(message):
            command = message.text.split()
            if len(command) == 2:
                steam_id = valid_steam_id(command[1])
                if steam_id:
                    if not message.from_user.id != player_is_registered(steam_id):
                        if user_is_registered(message.from_user.id):
                            reply_to(message, f"Your game account has been changed successfully.")
                        else:
                            registration = player_set_telegram_id(steam_id, message.from_user.id)
                            if registration:
                                reply_to(message, f"Your game account has been successfully linked.")
                            elif registration == False:
                                reply_to(message, f"The steam ID you provided wasn't found in the database. Did you login on the server at least once?")
                    else:
                        reply_to(message, f"Another user already registed this steam ID.")
                else:
                    reply_to(message, f"This is not a valid steam ID.")
            else:
                reply_to(message, register_msg_helper, disable_web_page_preview=True)
        # RESTART
        @bot.message_handler(commands=[restart_cmd])
        def restart_command(message):
            is_admin = member_is_admin(message)
            if is_admin:
                if check_service_status():
                    save_restart(restart_cmd, message.from_user.id)
                    reply_to(message, restart_msg)
                else:
                    reply_to(message, "The server is currently down.")
        @bot.message_handler(commands=[restart_confirm_cmd])
        def confirm_restart_command(message):
            restart_required = check_restart(restart_cmd, message.from_user.id)
            if restart_required:
                clear_restart(message.from_user.id)
                run_command("sudo systemctl restart " + get_servicename())
        @bot.message_handler(commands=[restart_cancel_cmd])
        def cancel_restart_command(message):
            clear_restart(message.from_user.id)
        # MOD INSTALL / UNINSTALL
        @bot.message_handler(commands=[mod_cmd])
        def mod_command(message):
            def list_mod_cmd():
                modid_list, workshopid_list = get_valid_modid_workshopid_list()
                if not len(modid_list) and not len(workshopid_list):
                    reply_to(message, "There are no mods installed.")
                elif not len(modid_list) or not len(workshopid_list):
                    reply_to(message, msg_no_mods_installed)
                    logger("Something must be wrong with the mod lists... Please check the config file.", "WARNING")
                elif len(modid_list) == len(workshopid_list):
                    counter = 0
                    for modid in modid_list:
                        counter += 1
                        workshopid = workshopid_list[modid_list.index(modid)]
                        reply_to(message, f"{counter}) {modid} [{workshopid}]\n\nhttps://steamcommunity.com/sharedfiles/filedetails/?id="+workshopid)
            def install_uninstall_mod_cmd(message, action, valid_IDs, source):
                if valid:
                    modid, workshopid = valid
                    is_installed = mod_is_installed(modid, workshopid)
                    if action == 'install':
                        if not is_installed:
                            if not force:
                                create_reform(message, 'mod', [action, modid, workshopid])
                            else:
                                install_mod(modid, workshopid)
                        elif is_installed:
                            reply_to(message, already_installed_msg)
                        else:
                            reply_to(message, msg_unhandled_exception)
                    elif action == 'uninstall':
                        if is_installed:
                            if not force:
                                create_reform(message, 'mod', [action, modid, workshopid])
                            else:
                                uninstall_mod(modid, workshopid)
                        elif not is_installed:
                            reply_to(message, msg_mod_not_installed)
                        else:
                            reply_to(message, msg_unhandled_exception)
                    else:
                        reply_to(message, mod_msg_helper)
                else:
                    if source == 'url':
                        reply_to(message, strip_modid_from_url_failed)
                    elif source == 'command':
                        reply_to(message, msg_modid_invalid)
                    elif source == 'file':
                        reply_to(message,  msg_workshopid_from_file_failed)
                    else:
                        reply_to(message, msg_unhandled_exception)
            def install_uninstall_mod_cmd_handler(message, force=False):
                command = message.text.split()
                if len(command) == 3:
                    if is_workshop_url(command[2]):
                        install_uninstall_mod_cmd(message, command[1], strip_IDs_from_steam(command[2]), 'url')
                    elif command[1] == 'uninstall':
                        install_uninstall_mod_cmd(message, command[1], get_workshopid_from_installed_mods(command[2]), 'file')
                    else:
                        reply_to(message, mod_msg_helper)
                elif len(command) == 4:
                    install_uninstall_mod_cmd(message, command[1], sort_valid_modid_workshopid(command[2], command[3]), 'command')
                else:
                    reply_to(message, mod_msg_helper)
            # Alright...
            command = message.text.split()
            if command[1] == 'list' and len(command) == 2:
                list_mod_cmd()
            elif command[1] in ['install', 'uninstall']:
                if not command[2] == 'force':
                    install_uninstall_mod_cmd_handler(message)
                elif message.from_user.id in DEVS:
                    install_uninstall_mod_cmd_handler(command, force=True)
                else:
                    reply_to(message, "Only my master can use this. You have no power here.")
            else:
                reply_to(message, mod_msg_helper)
        # MODIFY PZSERVER SETTINGS
        @bot.message_handler(commands=[setting_cmd])
        def setting_command(message):
            command = message.text.split()
            if command[1] == "get":
                if len(command) == 3:
                    if is_setting(command[2]):
                        reply_to(message, get_setting(command[2]).value)
                        reply_to(message, get_setting(command[2]).description)
                    else:
                        reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?")
                else:
                    reply_to(message, setting_msg_helper)
            elif command[1] == "set":
                if len(command) == 4:
                    if is_setting(command[2]):
                        create_reform(message, 'setting', [command[2], command[3]])
                    else:
                        reply_to(message, command[2]+" was not recognized as setting. Could it be currently absent in the file?")
                elif is_setting(command[2]) and command[2] in ["ServerWelcomeMessage", "Map", "PublicName", "PublicDescription", "DiscordChannel"]: # Exception List
                    import re
                    match = re.match(r"/setting set (\w+) (.+)", message.text)
                    if match:
                        content = match.group(2)
                        create_reform(message, 'setting', [command[2], content])
                    else:
                        reply_to(message, setting_msg_helper)
                else:
                    reply_to(message, setting_msg_helper)
            else:
                reply_to(message, setting_msg_helper)
        # LISTEN FOR UPDATES FROM YOUR NON-ANONYMOUS POLLS
        @bot.poll_answer_handler()
        def poll_vote_event(update):
            update_poll_vote(update.user.id, update.poll_id, update.option_ids)

        ########################################
        ### TELEBOT - START POLLING
        ########################################
        
        log_emendazio()
        bot.infinity_polling()
        
    except Exception as e:
        logger(e, "ERROR")
